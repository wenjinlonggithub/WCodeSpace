# 场景四：限流算法

## 业务背景
在高并发场景下，为了保护系统不被流量洪峰打垮，需要对请求进行限流。常见场景：
- API接口限流：每秒最多1000个请求
- 用户维度限流：单用户每分钟最多10个请求
- IP限流：单IP每秒最多100个请求
- 秒杀接口限流：保护下游服务

## 业务描述
某电商网站在大促期间，商品详情页QPS达到10万，数据库承受不住压力宕机。
需要在网关层实现限流，超过阈值的请求直接返回"系统繁忙"。

## 核心瓶颈

### 1. 流量突刺
瞬时流量可能是平时的10倍甚至100倍

### 2. 分布式限流
多个实例如何协同限流？

### 3. 精确度vs性能
- 精确限流需要全局计数器（性能差）
- 近似限流性能高但不够精确

## 技术实现方案

### 方案一：令牌桶算法（Token Bucket）

#### 原理
1. 以固定速率往桶里放入令牌
2. 请求需要获取令牌才能通过
3. 桶满时，令牌溢出丢弃
4. 桶空时，请求被拒绝

#### 特点
- 允许突发流量（桶内有令牌就能通过）
- 平滑限流（令牌以恒定速率生成）

#### 应用
- Guava RateLimiter
- Nginx limit_req模块

### 方案二：漏桶算法（Leaky Bucket）

#### 原理
1. 请求进入漏桶
2. 漏桶以固定速率流出
3. 桶满时，请求溢出被拒绝

#### 特点
- 强制平滑输出（无论输入多快，输出速率恒定）
- 不允许突发流量

### 方案三：固定窗口计数器

#### 原理
1. 将时间划分为固定窗口（如1分钟）
2. 每个窗口维护计数器
3. 请求到达时，计数器+1
4. 超过阈值，拒绝请求
5. 窗口结束，计数器重置

#### 缺陷
- 临界问题：窗口边界可能产生2倍流量
  ```
  0:59秒：1000个请求
  1:00秒：1000个请求
  实际1秒内：2000个请求（超限）
  ```

### 方案四：滑动窗口计数器

#### 原理
1. 将时间窗口划分为多个小格子
2. 每次请求时，滑动窗口前进
3. 统计窗口内所有格子的计数总和
4. 超过阈值则拒绝

#### 优势
- 解决固定窗口的临界问题
- 精度更高

### 方案对比

| 算法 | 突发流量 | 实现复杂度 | 精确度 | 适用场景 |
|------|---------|-----------|--------|---------|
| 令牌桶 | 允许 | 中 | 高 | 大部分场景（推荐） |
| 漏桶 | 不允许 | 中 | 高 | 需要绝对平滑输出 |
| 固定窗口 | 允许 | 低 | 低 | 精度要求不高 |
| 滑动窗口 | 允许 | 高 | 高 | 高精度场景 |

## 分布式限流方案

### 方案一：Redis + Lua

使用Redis计数器 + Lua脚本保证原子性

### 方案二：Nginx + Lua

在网关层限流，性能最高

### 方案三：Sentinel/Hystrix

微服务框架的限流组件

## 关键代码实现

见以下文件：
- `TokenBucketRateLimiter.java` - 令牌桶算法
- `SlidingWindowRateLimiter.java` - 滑动窗口算法
- `RedisRateLimiter.java` - 基于Redis的分布式限流
