# 场景一：高并发秒杀系统

## 业务背景
电商平台在双11、618等大促期间，会推出限量秒杀活动。例如：100台iPhone只卖1元，活动开始后会有百万级用户同时抢购。

## 业务描述
- 商品数量有限（如100件）
- 瞬时流量巨大（百万级QPS）
- 要求不能超卖
- 要求响应快速
- 防止恶意刷单

## 核心瓶颈

### 1. 数据库压力
直接操作数据库会导致：
- 大量连接占满数据库连接池
- 行锁竞争严重，吞吐量急剧下降
- MySQL单机QPS一般在1000-2000，远不能满足需求

### 2. 超卖问题
并发情况下，多个线程同时读取库存，可能出现超卖：
```
时刻1: 线程A读取库存=1
时刻2: 线程B读取库存=1
时刻3: 线程A扣减库存，余1-1=0
时刻4: 线程B扣减库存，余1-1=0（实际已经超卖）
```

### 3. 恶意请求
- 黄牛使用脚本刷单
- 单用户重复请求

## 技术实现方案

### 方案架构
```
用户请求 -> Nginx限流 -> 接口限流 -> Redis预减库存 -> 消息队列异步下单 -> MySQL持久化
```

### 核心技术点

#### 1. 分层过滤
- **前端限流**：按钮置灰，防止重复点击
- **Nginx限流**：限制单IP请求频率
- **网关限流**：令牌桶/漏桶算法
- **接口限流**：Guava RateLimiter

#### 2. Redis预减库存
- 使用Redis的DECR原子操作
- 库存扣减成功才进入后续流程
- QPS可达10万+

#### 3. 异步削峰
- 使用消息队列（RabbitMQ/Kafka）
- 解耦秒杀请求和订单处理
- 削峰填谷，保护数据库

#### 4. 数据库最终一致性
- 使用乐观锁（版本号）防止超卖
- SQL: `UPDATE stock SET count=count-1, version=version+1 WHERE id=? AND version=? AND count>0`

#### 5. 防止恶意刷单
- 用户维度限流：单用户5秒内只能请求1次
- 验证码机制
- 风控系统识别异常行为

### 关键代码实现

见以下文件：
- `SeckillService.java` - 秒杀核心逻辑
- `RedisStockService.java` - Redis库存管理
- `OrderQueueService.java` - 订单队列处理

## 性能指标
- **吞吐量**：10万QPS
- **响应时间**：P99 < 100ms
- **准确性**：零超卖
