# 场景九：电子签名回调重复日志问题

## 业务背景

医疗系统中,医生完成电子签名后,第三方电子签名平台(易签宝)会回调业务系统的签署接口。系统收到回调后需要：
1. 更新医生的签署状态
2. 记录签署日志(用于审计追踪)
3. 触发后续业务流程

为了防止并发问题,系统对签署接口使用了基于签署ID的Redis分布式锁。内部使用异步程序来处理签署状态更新和日志记录。

## 问题描述

### 核心问题
**在生产环境中发现,同一次签署会产生两条签署日志记录,导致数据冗余和审计混乱。**

### 问题表现
```
签署ID: SIGN_20260114_001
签署日志表中出现两条记录:
- 记录1: 2026-01-14 10:00:01.123  医生张三完成签署
- 记录2: 2026-01-14 10:00:01.456  医生张三完成签署
```

### 业务流程图
```
医生签署完成
    ↓
易签宝回调签署接口 (POST /api/signature/callback)
    ↓
根据签署ID加Redis锁 (key: "sign:lock:" + signatureId)
    ↓
获取锁成功 → 提交异步任务到线程池
    ↓                    ↓
释放锁              异步任务执行
                         ↓
                    更新签署状态
                         ↓
                    记录签署日志 ← 问题出现在这里!
```

## 问题原因分析

### 原因1: Redis锁的作用范围不足 (最可能 ⭐⭐⭐⭐⭐)

**问题描述:**
Redis锁只锁住了回调接口的同步部分,但异步任务的执行没有在锁的保护范围内。

```java
// 有问题的代码
@PostMapping("/callback")
public Result handleCallback(SignatureCallbackDTO dto) {
    String lockKey = "sign:lock:" + dto.getSignatureId();

    try {
        // 获取Redis锁
        boolean locked = redisLock.tryLock(lockKey, 10, TimeUnit.SECONDS);
        if (!locked) {
            return Result.fail("系统繁忙");
        }

        // 提交异步任务
        asyncService.processSignature(dto);  // 异步执行

        return Result.success();

    } finally {
        // 立即释放锁 ← 问题所在!
        redisLock.unlock(lockKey);
    }
}
```

**为什么会产生重复日志:**
1. 请求A获取锁,提交异步任务A,释放锁
2. 异步任务A还未执行完成
3. 请求B获取锁(因为请求A已经释放),提交异步任务B,释放锁
4. 异步任务A和异步任务B几乎同时执行,都记录了日志 → 产生重复

**时序图:**
```
时间轴    请求A线程           异步任务A          请求B线程          异步任务B
  |
  ├─→  获取锁成功
  ├─→  提交异步任务A ──→
  ├─→  释放锁
  |                                         ├─→  获取锁成功
  |                                         ├─→  提交异步任务B ──→
  |                                         ├─→  释放锁
  |                      ├─→ 开始执行                              ├─→ 开始执行
  |                      ├─→ 查询状态(未完成)                      ├─→ 查询状态(未完成)
  |                      ├─→ 更新状态                              ├─→ 更新状态
  |                      ├─→ 记录日志 ✓                            ├─→ 记录日志 ✓
  |                                                                       ↑
  |                                                                  重复日志!
```

### 原因2: 易签宝回调重试 (可能性 ⭐⭐⭐⭐)

**问题描述:**
第三方平台认为回调失败(如网络超时、返回非200状态码),会进行重试。

**触发场景:**
```
第1次回调: 10:00:01.000
  → 系统处理慢,超过易签宝超时时间(如5秒)
  → 易签宝未收到响应,认为失败

第2次回调(重试): 10:00:06.000
  → 系统正常处理

结果: 产生两次回调,两条日志
```

**如何验证:**
检查易签宝的回调日志,查看是否有重复的回调请求。

### 原因3: 异步任务重复提交 (可能性 ⭐⭐⭐)

**问题描述:**
异步任务被重复提交到线程池或消息队列。

**可能的代码问题:**
```java
// 错误示例: 在循环中重复提交
for (SignatureItem item : items) {
    // 可能因为逻辑错误,同一个item被处理多次
    asyncService.processSignature(item);
}
```

### 原因4: 数据库事务隔离级别问题 (可能性 ⭐⭐)

**问题描述:**
在READ_COMMITTED隔离级别下,两个并发事务都读取到"未记录日志"的状态,都执行插入操作。

```sql
-- 事务A和事务B几乎同时执行
-- 事务A:
SELECT COUNT(*) FROM signature_log WHERE signature_id = 'SIGN_001'; -- 返回0
INSERT INTO signature_log (...) VALUES (...); -- 插入成功

-- 事务B (同时进行):
SELECT COUNT(*) FROM signature_log WHERE signature_id = 'SIGN_001'; -- 也返回0
INSERT INTO signature_log (...) VALUES (...); -- 也插入成功!
```

### 原因5: 异步线程和主线程都记录了日志 (可能性 ⭐)

**问题描述:**
代码逻辑错误,在回调接口的主线程和异步任务中都调用了日志记录方法。

```java
@PostMapping("/callback")
public Result handleCallback(SignatureCallbackDTO dto) {
    // 主线程记录日志
    signatureLogService.recordLog(dto);  // 第一次记录

    // 异步任务也记录日志
    asyncService.processSignature(dto);  // 内部又记录一次
}
```

## 解决方案

### 方案1: 数据库唯一约束 + 异常捕获 (推荐 ⭐⭐⭐⭐⭐)

**原理:** 利用数据库层面的唯一约束,从根本上防止重复插入。

**优点:**
- 简单可靠,数据库层面保证
- 不依赖分布式锁,性能好
- 即使业务代码有bug也能兜底

**实现步骤:**

1. 在签署日志表添加唯一索引
```sql
-- 方案1: 单个签署ID只能有一条日志
ALTER TABLE signature_log ADD UNIQUE INDEX uk_signature_id (signature_id);

-- 方案2: 签署ID + 操作类型的组合唯一(如果一个签署有多种操作)
ALTER TABLE signature_log ADD UNIQUE INDEX uk_signature_operation
    (signature_id, operation_type);
```

2. 业务代码捕获重复插入异常
```java
@Service
public class SignatureLogService {

    public void recordLog(SignatureCallbackDTO dto) {
        try {
            SignatureLog log = new SignatureLog();
            log.setSignatureId(dto.getSignatureId());
            log.setDoctorName(dto.getDoctorName());
            log.setOperationType("SIGN_COMPLETE");
            log.setCreateTime(new Date());

            signatureLogMapper.insert(log);

        } catch (DuplicateKeyException e) {
            // 重复插入,忽略(说明已经记录过了)
            log.warn("签署日志已存在,忽略重复记录: signatureId={}",
                    dto.getSignatureId());
        }
    }
}
```

**效果:**
- 第一次插入成功
- 第二次插入因唯一约束冲突被数据库拒绝
- 业务代码捕获异常,正常返回

### 方案2: 先查后插 + 分布式锁 (推荐 ⭐⭐⭐⭐)

**原理:** 在插入前先检查是否已存在,并用分布式锁保护整个操作。

```java
@Service
public class SignatureAsyncService {

    @Async
    public void processSignature(SignatureCallbackDTO dto) {
        String lockKey = "sign:process:" + dto.getSignatureId();

        try {
            // 获取锁(包括异步任务的执行)
            boolean locked = redisLock.tryLock(lockKey, 30, TimeUnit.SECONDS);
            if (!locked) {
                log.warn("获取锁失败,可能正在处理: {}", dto.getSignatureId());
                return;
            }

            // 先查询是否已经记录过日志
            int count = signatureLogMapper.countBySignatureId(dto.getSignatureId());
            if (count > 0) {
                log.info("签署日志已存在,跳过: {}", dto.getSignatureId());
                return;
            }

            // 更新签署状态
            signatureService.updateStatus(dto.getSignatureId(), "COMPLETED");

            // 记录日志
            signatureLogService.recordLog(dto);

        } finally {
            redisLock.unlock(lockKey);
        }
    }
}
```

**注意事项:**
- 锁的key要包含签署ID,实现细粒度锁
- 锁的超时时间要大于业务执行时间
- 必须在finally中释放锁

### 方案3: 幂等性Token机制 (适合防止回调重试 ⭐⭐⭐⭐)

**原理:** 易签宝回调时携带唯一的Token,系统验证Token确保只处理一次。

```java
@PostMapping("/callback")
public Result handleCallback(
        @RequestParam String signatureId,
        @RequestParam String callbackToken,  // 易签宝生成的唯一token
        @RequestBody SignatureCallbackDTO dto) {

    // 验证token(Redis存储token,成功后删除)
    String tokenKey = "callback:token:" + callbackToken;
    Boolean isFirstTime = redisTemplate.delete(tokenKey);

    if (Boolean.FALSE.equals(isFirstTime)) {
        log.warn("重复回调,忽略: token={}", callbackToken);
        return Result.success("重复请求");
    }

    // 处理签署
    asyncService.processSignature(dto);

    return Result.success();
}

// 在接收到易签宝的签署请求时,先生成token并存储
public String initiateSignature(SignatureRequest request) {
    String callbackToken = UUID.randomUUID().toString();

    // 存储token到Redis,设置过期时间(如24小时)
    redisTemplate.opsForValue().set(
        "callback:token:" + callbackToken,
        "1",
        24,
        TimeUnit.HOURS
    );

    // 调用易签宝API,传入callbackToken
    eSignService.createSignature(request, callbackToken);

    return callbackToken;
}
```

### 方案4: 使用状态机 (适合复杂业务流程 ⭐⭐⭐)

**原理:** 通过状态机保证状态只能流转一次。

```java
@Service
public class SignatureStateMachine {

    @Transactional
    public boolean transitionToCompleted(String signatureId) {
        // 使用数据库的乐观锁更新状态
        int updated = signatureMapper.updateStatus(
            signatureId,
            "COMPLETED",  // 新状态
            "PENDING"     // 期望的旧状态
        );

        return updated > 0;  // 返回false说明状态已经变更过
    }
}

// Mapper SQL
@Update("UPDATE signature SET status = #{newStatus}, version = version + 1 " +
        "WHERE signature_id = #{signatureId} AND status = #{oldStatus}")
int updateStatus(@Param("signatureId") String signatureId,
                 @Param("newStatus") String newStatus,
                 @Param("oldStatus") String oldStatus);

// 使用
@Async
public void processSignature(SignatureCallbackDTO dto) {
    // 尝试状态流转
    boolean success = stateMachine.transitionToCompleted(dto.getSignatureId());

    if (!success) {
        log.info("签署状态已经是已完成,跳过处理: {}", dto.getSignatureId());
        return;
    }

    // 状态流转成功,才记录日志
    signatureLogService.recordLog(dto);
}
```

### 方案5: 消息队列去重 (适合高并发场景 ⭐⭐⭐)

**原理:** 将签署回调放入消息队列,利用消息队列的去重机制。

```java
// 生产者: 回调接口
@PostMapping("/callback")
public Result handleCallback(SignatureCallbackDTO dto) {
    // 发送到RabbitMQ,使用signatureId作为消息ID
    rabbitTemplate.convertAndSend(
        "signature.exchange",
        "signature.complete",
        dto,
        message -> {
            // 设置消息ID,实现去重
            message.getMessageProperties()
                   .setMessageId(dto.getSignatureId());
            return message;
        }
    );

    return Result.success();
}

// 消费者
@RabbitListener(queues = "signature.complete.queue")
public void handleSignatureComplete(SignatureCallbackDTO dto) {
    // 先查询是否已处理
    int count = signatureLogMapper.countBySignatureId(dto.getSignatureId());
    if (count > 0) {
        log.info("签署已处理过,跳过: {}", dto.getSignatureId());
        return;
    }

    // 处理签署
    signatureService.updateStatus(dto.getSignatureId(), "COMPLETED");
    signatureLogService.recordLog(dto);
}
```

## 最佳实践建议

### 1. 多层防护策略 (推荐)

结合多种方案,构建纵深防御体系:

```
第1层: 易签宝回调Token验证
  ↓
第2层: Redis分布式锁(包含异步任务)
  ↓
第3层: 业务状态检查(先查后插)
  ↓
第4层: 数据库唯一约束(最后一道防线)
```

### 2. 监控和告警

```java
@Aspect
@Component
public class SignatureLogAspect {

    @Around("execution(* SignatureLogService.recordLog(..))")
    public Object monitorLogRecord(ProceedingJoinPoint pjp) throws Throwable {
        String signatureId = ((SignatureCallbackDTO) pjp.getArgs()[0]).getSignatureId();

        try {
            Object result = pjp.proceed();

            // 记录成功
            metricsService.incrementCounter("signature.log.success");

            return result;

        } catch (DuplicateKeyException e) {
            // 发现重复插入,发送告警
            alertService.sendAlert(
                "发现重复签署日志",
                "signatureId: " + signatureId
            );

            metricsService.incrementCounter("signature.log.duplicate");

            throw e;
        }
    }
}
```

### 3. 日志追踪

在整个调用链路中使用TraceId:

```java
@PostMapping("/callback")
public Result handleCallback(SignatureCallbackDTO dto) {
    String traceId = UUID.randomUUID().toString();
    MDC.put("traceId", traceId);

    log.info("收到签署回调: signatureId={}, traceId={}",
            dto.getSignatureId(), traceId);

    try {
        // 将traceId传递给异步任务
        dto.setTraceId(traceId);
        asyncService.processSignature(dto);

        return Result.success();
    } finally {
        MDC.clear();
    }
}

@Async
public void processSignature(SignatureCallbackDTO dto) {
    // 恢复traceId
    MDC.put("traceId", dto.getTraceId());

    log.info("异步任务开始: signatureId={}", dto.getSignatureId());

    // 业务逻辑...

    log.info("异步任务完成: signatureId={}", dto.getSignatureId());

    MDC.clear();
}
```

## 问题排查步骤

当发现重复日志时,按以下步骤排查:

### 1. 查询数据库确认重复
```sql
-- 查找重复的签署日志
SELECT signature_id, COUNT(*) as cnt
FROM signature_log
GROUP BY signature_id
HAVING cnt > 1;

-- 查看具体的重复记录
SELECT * FROM signature_log
WHERE signature_id = 'SIGN_20260114_001'
ORDER BY create_time;
```

### 2. 分析日志时间差
```
如果两条日志时间差 < 100ms:
  → 可能是并发问题(锁失效、异步任务并发)

如果两条日志时间差 > 5秒:
  → 可能是易签宝回调重试
```

### 3. 检查Redis锁日志
```java
// 在获取锁和释放锁的地方加详细日志
log.info("尝试获取锁: lockKey={}, thread={}", lockKey, Thread.currentThread().getName());
if (locked) {
    log.info("获取锁成功: lockKey={}", lockKey);
} else {
    log.warn("获取锁失败: lockKey={}", lockKey);
}

// 释放锁
log.info("释放锁: lockKey={}", lockKey);
```

### 4. 查看易签宝回调日志
联系易签宝技术支持,查询回调记录:
- 是否有重复回调?
- 回调时间间隔?
- 回调返回的状态码?

### 5. 分析线程堆栈
```bash
# 在问题发生时,dump线程堆栈
jstack <pid> > thread_dump.txt

# 查找签署相关的线程
grep -A 20 "processSignature" thread_dump.txt
```

## 总结

### 问题核心
**Redis锁只保护了同步部分,异步任务没有在锁的保护下,导致并发执行产生重复日志。**

### 推荐解决方案排序
1. **数据库唯一约束** (最简单、最可靠)
2. **分布式锁包含异步任务** (适合对一致性要求高的场景)
3. **Token幂等性机制** (适合防止第三方回调重试)
4. **状态机** (适合复杂业务流程)
5. **消息队列去重** (适合高并发、异步解耦场景)

### 关键要点
- ✅ 分布式锁的范围要覆盖整个业务逻辑(包括异步任务)
- ✅ 数据库唯一约束是最后一道防线
- ✅ 先查后插,避免重复操作
- ✅ 第三方回调要考虑重试机制
- ✅ 完善的监控和日志追踪

### 面试要点
1. **能描述清楚问题场景和表现**
2. **能分析出多种可能的原因**
3. **能对比多种解决方案的优劣**
4. **能给出最佳实践建议**
5. **能说明排查步骤和监控方案**
