# 场景五：接口幂等性设计

## 业务背景
在分布式系统中，由于网络抖动、客户端重试、消息重复消费等原因，同一个请求可能被执行多次。为了保证数据一致性，需要实现接口幂等性。

## 业务描述
用户在支付页面点击"确认支付"按钮后，由于网络延迟，页面没有响应，用户又点击了一次。如果不做幂等处理，会导致：
- 重复扣款
- 重复创建订单
- 库存被多次扣减

## 什么是幂等性
对于同一个请求，无论执行多少次，产生的结果都是一样的。

## 常见场景

### 1. 支付接口
防止重复扣款

### 2. 订单创建
防止重复下单

### 3. 消息队列消费
消息可能被重复投递

### 4. 分布式事务
某个环节失败重试时，已成功的步骤不能重复执行

## 技术实现方案

### 方案一：唯一索引（数据库层）

#### 实现
在数据库表中添加唯一索引，利用数据库约束保证幂等性。

```sql
CREATE TABLE `orders` (
  `id` bigint PRIMARY KEY,
  `order_no` varchar(64) NOT NULL UNIQUE KEY,  -- 订单号唯一索引
  ...
);
```

#### 优势
- 实现简单
- 强一致性

#### 劣势
- 依赖数据库
- 异常处理复杂（需要捕获唯一索引冲突异常）

### 方案二：Token机制

#### 实现流程
1. 客户端请求服务端获取Token
2. 服务端生成Token存储到Redis（带过期时间）
3. 客户端携带Token请求业务接口
4. 服务端验证Token，并删除（Lua脚本保证原子性）
5. 执行业务逻辑

#### 优势
- 适用于前端重复提交
- 实现灵活

#### 劣势
- 增加一次网络请求
- 需要客户端配合

### 方案三：分布式锁

#### 实现
使用业务唯一标识（如订单号）作为锁的key，获取锁成功才执行业务。

```java
String lockKey = "order:create:" + orderNo;
if (tryLock(lockKey)) {
    try {
        // 执行业务
        createOrder(orderNo);
    } finally {
        unlock(lockKey);
    }
}
```

#### 优势
- 适用于各种场景
- 并发安全

#### 劣势
- 性能开销（Redis网络请求）
- 实现复杂度高

### 方案四：状态机

#### 实现
利用业务状态流转保证幂等性。

```sql
-- 只有状态为UNPAID时才能支付
UPDATE orders SET status='PAID'
WHERE order_no=? AND status='UNPAID'
```

#### 优势
- 符合业务逻辑
- 实现简单

#### 劣势
- 仅适用于有状态流转的场景

### 方案五：去重表

#### 实现
创建专门的去重表，记录已处理的请求。

```sql
CREATE TABLE `idempotent_record` (
  `id` bigint PRIMARY KEY,
  `request_id` varchar(64) NOT NULL UNIQUE KEY,
  `create_time` datetime
);
```

处理流程：
1. 检查去重表中是否存在request_id
2. 存在则返回（已处理）
3. 不存在则插入记录并执行业务（一个事务）

## 方案对比

| 方案 | 实现难度 | 性能 | 适用场景 |
|------|---------|------|---------|
| 唯一索引 | 低 | 高 | 数据库操作 |
| Token机制 | 中 | 中 | 前端重复提交 |
| 分布式锁 | 高 | 中 | 通用场景 |
| 状态机 | 低 | 高 | 有状态流转 |
| 去重表 | 中 | 中 | 通用场景 |

## 关键代码实现

见以下文件：
- `TokenIdempotentService.java` - 基于Token的幂等性实现
- `IdempotentAnnotation.java` - 基于注解的幂等性实现
