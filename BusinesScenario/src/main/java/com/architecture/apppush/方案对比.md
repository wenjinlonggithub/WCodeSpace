# APP在线状态检测方案对比

## 两种方案概览

### 方案一：WebSocket长连接（原方案）

**核心思路**：客户端与服务端建立WebSocket长连接，通过心跳保活，实时双向通信。

**流程**：
```
1. APP启动 → 建立WebSocket连接 → 写入Redis在线状态
2. 每30秒发送心跳 → 服务端重置TTL（60秒）
3. 推送消息 → 查询Redis → 在线：WebSocket推送，离线：极光推送
```

### 方案二：REST心跳上报（新方案）

**核心思路**：客户端定时调用REST接口上报心跳，服务端写入Redis（带TTL），推送时查询状态。

**流程**：
```
1. APP启动 → 启动定时任务（30秒）
2. 定时调用POST /api/heartbeat → 写入Redis（TTL 60秒）
3. 推送消息 → 查询Redis → 在线：不推送，离线：极光推送
```

## 详细对比

### 1. 技术实现

| 维度 | WebSocket方案 | REST心跳方案 |
|------|--------------|-------------|
| **服务端** | 需要WebSocket服务器（Netty/Spring WebSocket） | 普通HTTP接口即可 |
| **客户端** | 需要WebSocket库 | 普通HTTP客户端即可 |
| **连接维护** | 长连接，需要处理断线重连 | 无连接，每次独立请求 |
| **代码复杂度** | 中等 | 低 |
| **技术门槛** | 需要了解WebSocket协议 | 简单的HTTP请求 |

**示例代码对比**：

**WebSocket客户端**（Android）：
```kotlin
// 需要管理连接状态、心跳、重连
val webSocket = client.newWebSocket(request, object : WebSocketListener() {
    override fun onOpen(webSocket: WebSocket, response: Response) { }
    override fun onMessage(webSocket: WebSocket, text: String) { }
    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {
        // 重连逻辑
    }
})
```

**REST心跳客户端**（Android）：
```kotlin
// 简单的定时HTTP请求
WorkManager.getInstance(context).enqueueUniquePeriodicWork(
    "heartbeat",
    ExistingPeriodicWorkPolicy.KEEP,
    PeriodicWorkRequestBuilder<HeartbeatWorker>(30, TimeUnit.SECONDS).build()
)
```

### 2. 性能对比

| 维度 | WebSocket方案 | REST心跳方案 |
|------|--------------|-------------|
| **流量消耗** | 低（长连接复用，心跳包小） | 中（每次完整HTTP请求） |
| **电量消耗** | 低（保持连接，心跳轻量） | 中（定时唤醒网络模块） |
| **服务端资源** | 需维护大量长连接（内存占用） | 无连接维护，只处理请求 |
| **并发能力** | 单机1万-10万连接 | 单机10万+ QPS |

**流量对比**（假设10万在线用户，心跳30秒）：

**WebSocket**：
- 心跳包大小：约50字节
- 30秒流量：10万 × 50字节 = 5MB
- 每小时流量：5MB × 120 = 600MB

**REST**：
- HTTP请求大小：约200字节（包含Header）
- 30秒流量：10万 × 200字节 = 20MB
- 每小时流量：20MB × 120 = 2.4GB

**结论**：WebSocket流量消耗约为REST的1/4

### 3. 实时性对比

| 场景 | WebSocket方案 | REST心跳方案 |
|------|--------------|-------------|
| **在线状态更新延迟** | 实时（连接建立即更新） | 最多30秒（取决于心跳间隔） |
| **离线检测延迟** | 60秒（心跳超时） | 60秒（TTL过期） |
| **消息推送延迟** | 毫秒级（服务端主动推送） | 无法推送（需配合极光） |
| **状态准确性** | 高（连接断开立即感知） | 中（依赖心跳上报） |

### 4. 可靠性对比

| 场景 | WebSocket方案 | REST心跳方案 |
|------|--------------|-------------|
| **网络抖动** | 连接断开，需重连 | 单次请求失败，下次重试 |
| **APP切后台** | iOS会断开连接 | WorkManager可能被系统杀死 |
| **服务器重启** | 所有连接断开，需重连 | 无影响（无状态） |
| **扩展性** | 需考虑连接迁移 | 天然支持（无状态） |

### 5. 功能对比

| 功能 | WebSocket方案 | REST心跳方案 |
|------|--------------|-------------|
| **在线状态检测** | ✅ 支持 | ✅ 支持 |
| **服务端主动推送** | ✅ 支持 | ❌ 不支持 |
| **实时双向通信** | ✅ 支持 | ❌ 不支持 |
| **离线消息推送** | ✅ 通过极光 | ✅ 通过极光 |
| **多端登录** | ✅ 支持 | ✅ 支持 |

## 实际案例分析

### 案例1：IM聊天应用（微信、钉钉）

**需求**：
- 实时接收消息
- 显示对方"正在输入"
- 消息已读回执
- 在线状态实时更新

**推荐方案**：**WebSocket**

**理由**：
- 需要实时双向通信
- 消息推送延迟要求极低（秒级）
- 用户在线时频繁交互

### 案例2：电商APP（淘宝、京东）

**需求**：
- 订单状态更新通知
- 促销活动推送
- 物流信息更新
- 在线时不打扰，离线时推送

**推荐方案**：**REST心跳**

**理由**：
- 不需要实时双向通信
- 消息推送通过极光即可
- 减少技术复杂度和维护成本
- 节省服务器资源

### 案例3：社交APP（抖音、小红书）

**需求**：
- 点赞、评论通知
- 私信消息
- 系统通知
- 在线时App内弹窗，离线时系统通知

**推荐方案**：**混合方案**

**理由**：
- 前台：WebSocket（实时私信）
- 后台：REST心跳（判断在线状态）
- 推送：极光（离线通知）

## 成本分析

### 开发成本

| 阶段 | WebSocket方案 | REST心跳方案 |
|------|--------------|-------------|
| **服务端开发** | 3-5人日 | 1-2人日 |
| **客户端开发** | 2-3人日/平台 | 1人日/平台 |
| **测试调试** | 3-5人日 | 1-2人日 |
| **总计** | 约10-15人日 | 约5-8人日 |

### 运维成本

| 维度 | WebSocket方案 | REST心跳方案 |
|------|--------------|-------------|
| **服务器成本** | 高（需维护长连接） | 中（无状态，易扩展） |
| **带宽成本** | 低 | 中 |
| **监控复杂度** | 高（连接数、心跳超时等） | 低（普通HTTP监控） |

## 选型决策树

```
是否需要服务端主动推送消息？
├─ 是 → 是否要求实时性（秒级）？
│   ├─ 是 → WebSocket方案
│   └─ 否 → REST心跳 + 极光推送
└─ 否 → 是否只需判断在线状态？
    ├─ 是 → REST心跳方案（推荐）
    └─ 否 → 根据其他需求选择
```

## 推荐方案

### 场景A：纯推送通知场景（推荐REST心跳）

**适用**：
- 电商APP
- 新闻资讯APP
- 工具类APP

**优势**：
- 实现简单，开发快
- 维护成本低
- 服务端无状态，易扩展

**实现**：
```java
// 服务端
@PostMapping("/api/heartbeat")
public HeartbeatResponse heartbeat(@RequestBody HeartbeatRequest request) {
    return heartbeatService.reportHeartbeat(request);
}

// 推送时判断
if (heartbeatService.isUserOnline(userId)) {
    // 在线：不推送（或静默推送）
} else {
    // 离线：极光推送
    jpushClient.push(userId, message);
}
```

### 场景B：实时通讯场景（推荐WebSocket）

**适用**：
- IM聊天
- 在线客服
- 实时协作工具

**优势**：
- 实时双向通信
- 延迟低
- 用户体验好

**实现**：
```java
// 服务端
@OnMessage
public void onMessage(String userId, String message) {
    // 处理消息
}

// 推送消息
webSocketServer.sendToUser(userId, message);
```

### 场景C：混合场景（推荐混合方案）

**适用**：
- 社交APP（既有私信又有通知）
- 直播APP（既有弹幕又有点赞通知）

**实现**：
- **前台在线**：WebSocket实时通信
- **后台/离线**：REST心跳判断状态 + 极光推送
- **推送策略**：根据消息类型和在线状态智能选择

## 迁移建议

### 从WebSocket迁移到REST心跳

**适用场景**：
- 不需要实时双向通信
- 想降低技术复杂度
- 想节省服务器成本

**迁移步骤**：
1. 保留WebSocket服务（兼容老版本）
2. 新增REST心跳接口
3. 新版本APP使用REST心跳
4. 灰度发布，观察效果
5. 老版本逐步升级
6. 下线WebSocket服务

### 从REST心跳升级到WebSocket

**适用场景**：
- 业务发展需要实时通信
- 用户增长，推送成本高
- 需要实现IM功能

**迁移步骤**：
1. 搭建WebSocket服务
2. 新版本APP支持WebSocket
3. 双模式运行（WebSocket优先，REST降级）
4. 监控数据，调优参数
5. 逐步提升WebSocket比例

## 总结

| 方案 | 优势 | 劣势 | 适用场景 |
|------|------|------|---------|
| **WebSocket** | 实时性高、双向通信、流量省 | 复杂度高、长连接维护 | IM聊天、在线客服 |
| **REST心跳** | 实现简单、维护容易、易扩展 | 实时性差、无法推送 | 纯推送通知场景 |
| **混合方案** | 兼顾实时性和成本 | 技术复杂度最高 | 大型社交APP |

**核心结论**：
- **只需判断在线状态 + 推送通知** → REST心跳（推荐）
- **需要实时双向通信** → WebSocket
- **复杂业务场景** → 混合方案

你的场景（APP离线才推送，在线不推送）非常适合使用 **REST心跳方案**！
