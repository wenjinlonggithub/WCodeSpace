# 微信小程序长期订阅消息 - 43101错误深度分析

## 问题背景

**长期订阅消息**是微信针对特定行业开放的功能，与一次性订阅消息的核心区别：

| 特性 | 一次性订阅 | 长期订阅 |
|------|----------|---------|
| 行业限制 | 无 | 仅限特定行业 |
| 发送次数 | 授权1次 = 发送1次 | 授权1次 = 无限次发送 |
| 用户控制 | 自动消费 | 可随时开关 |
| 权限申请 | 无需申请 | 需要单独申请 |

## 长期订阅消息的特殊性

### 1. 适用行业

根据微信官方文档，长期订阅仅限以下行业：

```
✅ 政务民生
✅ 医疗健康
✅ 交通运输
✅ 金融保险
✅ 教育培训
✅ 生活服务（部分子类目）
```

**重要**：普通电商、新闻资讯等行业**无法使用**长期订阅！

### 2. 申请条件

```
1. 小程序主体类目必须符合要求
2. 需要在小程序后台单独申请
3. 通过审核后才能使用
4. 模板需要使用长期订阅类型的模板ID
```

### 3. 订阅机制

```javascript
// 长期订阅的授权方式
wx.requestSubscribeMessage({
  tmplIds: ['long_term_template_id']  // 必须是长期订阅模板
})

// 用户授权后：
// ✅ 可以无限次发送（直到用户主动关闭）
// ✅ 用户可以在设置中随时开关
// ✅ 开关状态会实时生效
```

## 长期订阅消息的43101错误原因

### 与一次性订阅的区别

一次性订阅的43101主要是**次数用完**，而长期订阅的43101主要是：

### 原因1：用户在设置中关闭了订阅 ⭐⭐⭐⭐⭐

**这是最常见的原因！**

```
用户路径：
小程序设置 → 通知管理 → 订阅消息 → 关闭某个模板

系统状态：
小程序端显示：拒绝 ❌
服务端发送：43101 ❌
```

**关键点**：
- 用户关闭订阅后，状态会**立即同步到微信服务器**
- 后端再次发送会立即返回43101
- 小程序端的显示状态与服务端**完全一致**（不像一次性订阅会不一致）

### 原因2："总是保持选择"的历史遗留问题 ⭐⭐⭐⭐

**这是长期订阅最坑的问题！**

```
问题场景：
1. 用户首次授权时，勾选了"总是保持以上选择，不再询问"
2. 并且选择了"拒绝"
3. 之后用户在设置中手动改为"接受"
4. 但系统仍然记录了"永久拒绝"的标记
5. 导致即使显示"接受"，发送仍然返回43101

微信的BUG：
当用户勾选"总是保持选择"并拒绝后，
即使后续在设置中打开，
底层的"永久拒绝"标记可能不会清除！
```

**验证方法**：
```javascript
// 检查用户是否有"永久拒绝"标记
wx.getSetting({
  withSubscriptions: true,
  success(res) {
    console.log(res.subscriptionsSetting)
    // 如果 mainSwitch 为 false，说明用户关闭了总开关
    // 如果某个模板显示 'reject'，但用户说已经打开，可能是BUG
  }
})
```

**官方社区反馈**：
- [订阅消息后，为什么直接提示user refuse to accept](https://developers.weixin.qq.com/community/develop/doc/000666487a0928a452b03929266400)
- [subscribeMessage开始能发送消息，但后来手动不接收消息，再次开启后，怎就一直接收不了](https://developers.weixin.qq.com/community/develop/doc/000004239a0138c769696d4f256400)

### 原因3：用户从未授权过 ⭐⭐⭐

```
场景：
后端直接调用发送接口，但用户从未在小程序中授权

常见于：
1. 测试环境直接调用
2. 从后台导入的用户数据
3. 业务逻辑错误，未检查用户是否已授权
```

### 原因4：模板被封禁或停用 ⭐⭐

```
场景：
1. 模板因违规被微信封禁
2. 模板审核未通过
3. 模板被开发者主动停用

检查方法：
登录小程序后台 → 功能 → 订阅消息 → 查看模板状态
```

### 原因5：用户的订阅关系被清除 ⭐

```
罕见场景：
1. 用户删除小程序后重新添加
2. 小程序被封禁后恢复
3. 微信系统异常导致订阅关系丢失
```

## 长期订阅vs一次性订阅的43101对比

```
┌─────────────────────────────────────────────────────────┐
│ 一次性订阅消息的43101                                       │
├─────────────────────────────────────────────────────────┤
│ 主要原因：次数用完（80%）                                   │
│ 特征：前端显示"接受"，但实际次数为0                          │
│ 解决方案：引导用户重新授权                                  │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ 长期订阅消息的43101                                        │
├─────────────────────────────────────────────────────────┤
│ 主要原因：用户主动关闭（70%）+ "总是保持选择"BUG（20%）      │
│ 特征：前端显示与实际状态可能一致，也可能不一致                │
│ 解决方案：检查设置 + 重置订阅关系                           │
└─────────────────────────────────────────────────────────┘
```

## 长期订阅43101的排查流程

### 步骤1：确认是否为长期订阅模板

```java
// 后端检查
@Service
public class TemplateCheckService {

    /**
     * 检查模板类型
     */
    public String checkTemplateType(String templateId) {
        // 方法1：查询本地配置
        TemplateConfig config = templateRepo.findByTemplateId(templateId);
        if (config != null) {
            return config.getType(); // ONE_TIME 或 LONG_TERM
        }

        // 方法2：根据模板ID前缀判断（如果有规律）
        if (templateId.startsWith("long_")) {
            return "LONG_TERM";
        }

        return "ONE_TIME";
    }
}
```

### 步骤2：检查用户授权状态

```javascript
// 前端检查
async function checkSubscriptionStatus(templateId) {
  const res = await wx.getSetting({
    withSubscriptions: true
  })

  console.log('总开关：', res.subscriptionsSetting.mainSwitch)
  console.log('模板状态：', res.subscriptionsSetting.itemSettings?.[templateId])

  return {
    mainSwitch: res.subscriptionsSetting.mainSwitch,
    templateStatus: res.subscriptionsSetting.itemSettings?.[templateId]
  }
}
```

### 步骤3：判断是否为"总是保持选择"BUG

```javascript
/**
 * 检测"总是保持选择"BUG
 */
async function detectAlwaysKeepBug(templateId) {
  const status = await checkSubscriptionStatus(templateId)

  // 特征1：总开关打开
  // 特征2：模板显示"接受"或"接受with音频"
  // 特征3：但后端发送仍然返回43101

  if (status.mainSwitch &&
      (status.templateStatus === 'accept' ||
       status.templateStatus === 'acceptWithAudio')) {

    // 很可能是"总是保持选择"BUG
    console.warn('检测到可能的"总是保持选择"BUG')
    return true
  }

  return false
}
```

### 步骤4：尝试重置订阅关系

```javascript
/**
 * 重置订阅关系（唯一解决方案）
 */
async function resetSubscription(templateId) {
  wx.showModal({
    title: '订阅异常',
    content: '检测到订阅状态异常，需要重置订阅关系。请按以下步骤操作：\n\n1. 删除本小程序\n2. 重新搜索并进入\n3. 重新授权订阅\n\n或者，您可以尝试重新授权一次',
    confirmText: '重新授权',
    cancelText: '稍后再说',
    success: async (res) => {
      if (res.confirm) {
        // 尝试重新授权
        const authRes = await wx.requestSubscribeMessage({
          tmplIds: [templateId]
        })

        if (authRes[templateId] === 'accept') {
          wx.showToast({ title: '授权成功' })
          // 通知后端更新状态
          await api.updateSubscription(templateId)
        } else {
          // 授权失败，引导用户删除小程序
          showDeleteGuide()
        }
      }
    }
  })
}

/**
 * 引导用户删除小程序（最终解决方案）
 */
function showDeleteGuide() {
  wx.showModal({
    title: '解决方案',
    content: '如果问题持续存在，请尝试以下操作：\n\n1. 长按小程序图标\n2. 选择"删除"\n3. 重新搜索小程序名称\n4. 重新进入并授权\n\n这样可以彻底清除订阅缓存',
    showCancel: false,
    confirmText: '我知道了'
  })
}
```

## 长期订阅的后端实现

### 1. 订阅状态管理

```java
/**
 * 长期订阅状态管理
 */
@Service
public class LongTermSubscriptionManager {

    @Autowired
    private WechatSubscriptionRepository subscriptionRepo;

    /**
     * 用户授权长期订阅
     */
    @Transactional
    public void onUserSubscribe(String userId, String openid, String templateId) {
        Optional<WechatSubscription> existing = subscriptionRepo
            .findByUserIdAndTemplateId(userId, templateId);

        if (existing.isPresent()) {
            // 已有订阅，更新状态为激活
            WechatSubscription subscription = existing.get();
            subscription.setStatus("ACTIVE");
            subscription.setRemainingCount(999); // 长期订阅，设为999表示不限次数
            subscription.setSubscribeTime(LocalDateTime.now());
            subscription.setExpireTime(null); // 长期订阅无过期时间
            subscriptionRepo.save(subscription);
        } else {
            // 新建订阅
            WechatSubscription subscription = new WechatSubscription();
            subscription.setUserId(userId);
            subscription.setOpenid(openid);
            subscription.setTemplateId(templateId);
            subscription.setRemainingCount(999); // 不限次数
            subscription.setSubscribeTime(LocalDateTime.now());
            subscription.setExpireTime(null); // 无过期时间
            subscription.setStatus("ACTIVE");
            subscriptionRepo.save(subscription);
        }

        log.info("长期订阅授权成功，userId: {}, templateId: {}", userId, templateId);
    }

    /**
     * 用户关闭订阅
     */
    @Transactional
    public void onUserUnsubscribe(String userId, String templateId) {
        Optional<WechatSubscription> optional = subscriptionRepo
            .findByUserIdAndTemplateId(userId, templateId);

        if (optional.isPresent()) {
            WechatSubscription subscription = optional.get();
            subscription.setStatus("UNSUBSCRIBED"); // 用户主动取消
            subscriptionRepo.save(subscription);

            log.info("用户关闭长期订阅，userId: {}, templateId: {}", userId, templateId);
        }
    }

    /**
     * 处理43101错误
     */
    @Transactional
    public void handle43101Error(String userId, String templateId) {
        Optional<WechatSubscription> optional = subscriptionRepo
            .findByUserIdAndTemplateId(userId, templateId);

        if (optional.isPresent()) {
            WechatSubscription subscription = optional.get();

            // 长期订阅的43101通常是用户主动关闭
            subscription.setStatus("UNSUBSCRIBED");
            subscription.setRemark("43101错误：用户可能在设置中关闭了订阅，或存在'总是保持选择'BUG");
            subscriptionRepo.save(subscription);

            // 发送通知给运营人员
            notifyOps(userId, templateId, "用户订阅状态异常，需要引导用户重新授权");
        }
    }

    /**
     * 检查是否可发送（长期订阅版本）
     */
    public boolean canSend(String userId, String templateId) {
        Optional<WechatSubscription> optional = subscriptionRepo
            .findByUserIdAndTemplateIdAndStatus(userId, templateId, "ACTIVE");

        // 长期订阅只需检查是否有激活的订阅记录
        // 不需要检查次数和过期时间
        return optional.isPresent();
    }
}
```

### 2. 发送消息时的处理

```java
/**
 * 长期订阅消息发送
 */
@Service
public class LongTermMessageSender {

    @Autowired
    private WxMaService wxMaService;

    @Autowired
    private LongTermSubscriptionManager subscriptionManager;

    /**
     * 发送长期订阅消息
     */
    public SendResult send(String userId, String openid, String templateId,
                           Map<String, String> data, String page) {

        // 1. 检查订阅状态
        if (!subscriptionManager.canSend(userId, templateId)) {
            return SendResult.fail("用户未订阅或已关闭订阅");
        }

        // 2. 构建消息
        WxMaSubscribeMessage message = buildMessage(openid, templateId, data, page);

        // 3. 发送
        try {
            wxMaService.getMsgService().sendSubscribeMsg(message);
            log.info("长期订阅消息发送成功，userId: {}", userId);
            return SendResult.success();

        } catch (WxErrorException e) {
            int errorCode = e.getError().getErrorCode();

            if (errorCode == 43101) {
                log.warn("43101错误，用户可能已关闭订阅，userId: {}", userId);

                // 同步本地状态
                subscriptionManager.handle43101Error(userId, templateId);

                // 触发重新引导流程
                triggerResubscribeGuide(userId, templateId);

                return SendResult.fail("用户已关闭订阅，需要重新引导授权");
            }

            return SendResult.fail("发送失败：" + e.getMessage());
        }
    }

    /**
     * 触发重新引导流程
     *
     * 可以通过以下方式通知用户：
     * 1. 在用户下次打开小程序时弹窗提醒
     * 2. 在相关业务页面展示提示
     * 3. 通过公众号或短信通知
     */
    private void triggerResubscribeGuide(String userId, String templateId) {
        // 记录到待引导表
        GuideRecord guide = new GuideRecord();
        guide.setUserId(userId);
        guide.setTemplateId(templateId);
        guide.setReason("43101");
        guide.setStatus("PENDING");
        guideRepo.save(guide);

        log.info("已创建重新引导记录，userId: {}", userId);
    }
}
```

## 前端最佳实践

### 1. 定期检查订阅状态

```javascript
/**
 * 应用启动时检查订阅状态
 */
App({
  async onLaunch() {
    await this.checkSubscriptionStatus()
  },

  async checkSubscriptionStatus() {
    const longTermTemplates = [
      'long_term_template_1',
      'long_term_template_2'
    ]

    const res = await wx.getSetting({
      withSubscriptions: true
    })

    for (let templateId of longTermTemplates) {
      const status = res.subscriptionsSetting.itemSettings?.[templateId]

      // 如果用户关闭了订阅，通知后端
      if (status === 'reject' || !status) {
        await api.notifyUnsubscribed(templateId)
      } else if (status === 'accept') {
        // 确认订阅状态
        await api.confirmSubscribed(templateId)
      }
    }
  }
})
```

### 2. 处理订阅状态变化

```javascript
/**
 * 监听用户在设置中修改订阅状态
 */
Page({
  onShow() {
    // 每次页面显示时检查订阅状态
    this.checkAndSyncSubscriptionStatus()
  },

  async checkAndSyncSubscriptionStatus() {
    const currentStatus = await checkSubscriptionStatus('long_term_template')

    // 与本地缓存对比
    const cachedStatus = wx.getStorageSync('subscription_status')

    if (currentStatus.templateStatus !== cachedStatus) {
      // 状态发生变化，同步到后端
      if (currentStatus.templateStatus === 'accept') {
        await api.notifySubscribed('long_term_template')
      } else {
        await api.notifyUnsubscribed('long_term_template')
      }

      // 更新本地缓存
      wx.setStorageSync('subscription_status', currentStatus.templateStatus)
    }
  }
})
```

### 3. 引导用户重新订阅

```javascript
/**
 * 当后端返回43101时的处理
 */
async function handleSubscriptionError() {
  // 1. 检查当前状态
  const status = await checkSubscriptionStatus('long_term_template')

  if (status.templateStatus === 'accept') {
    // 显示"接受"但仍然43101 = "总是保持选择"BUG
    wx.showModal({
      title: '订阅状态异常',
      content: '检测到订阅状态异常，这可能是因为您之前勾选了"总是保持以上选择"导致的。\n\n解决方法：\n1. 删除小程序\n2. 重新进入并授权\n\n或者现在重新授权试试',
      confirmText: '重新授权',
      cancelText: '稍后处理',
      success: async (res) => {
        if (res.confirm) {
          await resetSubscription('long_term_template')
        }
      }
    })
  } else {
    // 状态为拒绝，正常引导
    wx.showModal({
      title: '开启订阅',
      content: '您已关闭了订阅消息，开启后可以接收重要通知',
      confirmText: '去开启',
      success: async (res) => {
        if (res.confirm) {
          await wx.requestSubscribeMessage({
            tmplIds: ['long_term_template']
          })
        }
      }
    })
  }
}
```

## 监控与预警

### 1. 43101错误率监控

```java
/**
 * 长期订阅43101错误监控
 */
@Component
public class LongTermSubscriptionMonitor {

    @Scheduled(cron = "0 */5 * * * ?") // 每5分钟
    public void monitor43101ErrorRate() {
        // 统计最近1小时的发送情况
        LocalDateTime startTime = LocalDateTime.now().minusHours(1);

        List<MessageLog> logs = messageLogRepo
            .findByTemplateTypeAndSendTimeAfter("LONG_TERM", startTime);

        long totalCount = logs.size();
        long error43101Count = logs.stream()
            .filter(log -> log.getErrorCode() != null && log.getErrorCode() == 43101)
            .count();

        if (totalCount > 0) {
            double errorRate = (double) error43101Count / totalCount;

            if (errorRate > 0.1) { // 超过10%
                alert(String.format(
                    "长期订阅43101错误率过高：%.2f%% (总数:%d, 43101:%d)",
                    errorRate * 100, totalCount, error43101Count
                ));
            }
        }
    }

    /**
     * 分析43101错误原因
     */
    public Map<String, Object> analyze43101Errors() {
        LocalDateTime startTime = LocalDateTime.now().minusDays(7);

        List<MessageLog> error43101Logs = messageLogRepo
            .findByErrorCodeAndSendTimeAfter(43101, startTime);

        // 统计受影响的用户数
        long affectedUsers = error43101Logs.stream()
            .map(MessageLog::getUserId)
            .distinct()
            .count();

        // 统计各模板的错误分布
        Map<String, Long> templateErrors = error43101Logs.stream()
            .collect(Collectors.groupingBy(
                MessageLog::getTemplateId,
                Collectors.counting()
            ));

        return Map.of(
            "total43101Count", error43101Logs.size(),
            "affectedUsers", affectedUsers,
            "templateErrors", templateErrors,
            "avgErrorsPerUser", error43101Logs.size() / (double) affectedUsers
        );
    }
}
```

### 2. 用户订阅状态同步

```java
/**
 * 定期同步用户订阅状态
 */
@Component
public class SubscriptionSyncService {

    /**
     * 对于频繁出现43101的用户，主动检查订阅状态
     */
    @Scheduled(cron = "0 0 3 * * ?") // 每天凌晨3点
    public void syncFrequent43101Users() {
        // 查询最近7天内43101次数>=3的用户
        LocalDateTime startTime = LocalDateTime.now().minusDays(7);

        List<Object[]> frequent43101Users = messageLogRepo
            .findFrequent43101Users(startTime, 3);

        for (Object[] row : frequent43101Users) {
            String userId = (String) row[0];
            String templateId = (String) row[1];
            Long errorCount = (Long) row[2];

            log.info("用户 {} 模板 {} 最近7天43101次数: {}",
                userId, templateId, errorCount);

            // 标记需要重新引导
            markForResubscribeGuide(userId, templateId);
        }
    }
}
```

## 给用户的明确说明

### 用户FAQ

**Q1: 为什么我明明开启了订阅，却收不到消息？**

A: 可能是以下原因：
1. 您在小程序设置中关闭了订阅（请检查：设置→通知管理→订阅消息）
2. 您之前勾选了"总是保持以上选择"并拒绝，导致系统记录了永久拒绝
3. 解决方法：删除小程序后重新进入，重新授权订阅

**Q2: 什么是"总是保持以上选择"？为什么会有问题？**

A: 这是微信授权弹窗上的一个选项。如果您勾选了这个选项并选择"拒绝"，即使后续在设置中打开，系统可能仍然认为您拒绝了。这是微信的已知问题。

**Q3: 如何彻底解决订阅问题？**

A: 最彻底的方法：
1. 长按小程序图标，选择"删除"
2. 重新搜索小程序名称
3. 重新进入小程序
4. 重新授权订阅（注意不要勾选"总是保持以上选择"）

## 总结

### 长期订阅43101的核心原因

```
1. 用户主动关闭订阅（70%）✅ 正常行为
2. "总是保持选择"BUG（20%）❌ 微信BUG
3. 用户从未授权（8%）✅ 业务问题
4. 其他异常（2%）❌ 系统问题
```

### 解决策略

```
1. 后端：本地化管理订阅状态，不依赖微信接口查询
2. 前端：定期同步订阅状态，及时发现变化
3. 监控：设置43101错误率报警，及时发现问题
4. 引导：提供清晰的重新订阅流程，特别是"删除小程序"方案
5. 文档：明确告知用户"总是保持选择"的风险
```

### 与一次性订阅的关键区别

| 维度 | 一次性订阅 | 长期订阅 |
|------|----------|---------|
| 43101主因 | 次数用完 | 用户关闭 |
| 状态一致性 | 经常不一致 | 通常一致 |
| 解决难度 | 简单（重新授权） | 困难（可能需要删除小程序） |
| BUG影响 | 较小 | 较大 |

## 官方文档

1. **长期订阅消息说明**
   - https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/subscribe-message.html

2. **行业分类要求**
   - https://developers.weixin.qq.com/miniprogram/product/material/

3. **社区讨论**
   - https://developers.weixin.qq.com/community/develop/doc/000666487a0928a452b03929266400

---

**文档更新时间**：2026-01-14
**适用场景**：长期订阅消息
**维护者**：开发团队
