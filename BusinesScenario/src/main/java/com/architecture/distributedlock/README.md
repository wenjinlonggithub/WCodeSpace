# 场景二：分布式锁

## 业务背景
在分布式系统中，多个应用实例需要对共享资源进行互斥访问。例如：
- 定时任务去重：防止多个实例同时执行同一个任务
- 库存扣减：保证扣减操作的原子性
- 订单号生成：保证订单号全局唯一
- 缓存重建：防止缓存击穿时多个请求同时重建缓存

## 业务描述
某电商系统部署了3个实例，每个实例都配置了定时任务"每天凌晨1点统计昨日订单"。如果不加控制，会导致：
- 3个实例同时执行，产生重复统计
- 数据库压力增大3倍
- 可能产生脏数据

需要使用分布式锁保证同一时刻只有一个实例执行任务。

## 核心瓶颈

### 1. 单机锁失效
Java的synchronized、ReentrantLock只能在单JVM内生效，无法跨进程。

### 2. 死锁风险
如果获取锁的节点宕机，锁无法释放，导致其他节点永久阻塞。

### 3. 锁的可重入性
同一线程多次获取锁时，需要支持重入。

### 4. 锁的过期问题
- 设置过期时间太短：业务还没执行完，锁就过期了，其他节点抢到锁
- 设置过期时间太长：节点宕机后，锁长时间无法释放

### 5. 锁误删问题
A线程获取锁并设置10秒过期，但业务执行了15秒，锁已自动过期。
此时B线程获取了锁，A线程执行完后误删了B的锁。

## 技术实现方案

### 方案一：基于Redis的分布式锁（推荐）

#### 实现原理
使用Redis的SET NX EX命令：
```
SET key value NX EX 30
```
- NX：只在key不存在时设置成功（互斥性）
- EX：设置过期时间（避免死锁）
- value：使用UUID，释放时校验（避免误删）

#### 核心代码逻辑
```java
// 加锁
String lockValue = UUID.randomUUID().toString();
boolean locked = redis.set(key, lockValue, "NX", "EX", 30);

// 业务逻辑
if (locked) {
    try {
        // 执行业务
    } finally {
        // 释放锁（Lua脚本保证原子性）
        releaseLock(key, lockValue);
    }
}
```

#### 改进方案：Redisson
Redisson是Redis官方推荐的Java客户端，提供了完善的分布式锁实现：
- **看门狗机制**：自动续期，防止业务执行时间过长导致锁过期
- **可重入锁**：支持同一线程多次获取
- **公平锁**：支持FIFO队列
- **读写锁**：支持共享锁和排他锁

### 方案二：基于Zookeeper的分布式锁

#### 实现原理
利用Zookeeper的临时顺序节点：
1. 客户端创建临时顺序节点：`/locks/lock_0000000001`
2. 获取`/locks`下所有子节点，判断自己是否是最小节点
3. 如果是最小节点，获取锁成功
4. 如果不是，监听前一个节点的删除事件
5. 前一个节点删除后，重新判断是否是最小节点

#### 优势
- 自动删除：临时节点在客户端断开连接后自动删除，避免死锁
- 公平锁：天然支持FIFO
- 高可用：Zookeeper集群保证可用性

#### 劣势
- 性能较低：每次加锁需要创建节点，释放锁需要删除节点
- 复杂度高：需要维护Zookeeper集群

### 方案对比

| 特性 | Redis | Zookeeper |
|------|-------|-----------|
| 性能 | 高（10万QPS+） | 中（1万QPS） |
| 可靠性 | 中（主从切换可能丢锁） | 高（强一致性） |
| 实现复杂度 | 简单 | 复杂 |
| 适用场景 | 高并发、对可靠性要求不极致 | 对可靠性要求极高 |

### 推荐方案
- **一般场景**：使用Redisson，简单高效
- **强一致性场景**：使用Zookeeper
- **超高并发场景**：使用Redis + Redisson看门狗

## 关键代码实现

见以下文件：
- `RedisDistributedLock.java` - 基于Redis的分布式锁（原生实现）
- `RedissonLockExample.java` - 基于Redisson的分布式锁（推荐）
- `ZookeeperDistributedLock.java` - 基于Zookeeper的分布式锁

## 注意事项

1. **一定要设置过期时间**：防止死锁
2. **释放锁时校验value**：防止误删
3. **使用Lua脚本**：保证操作原子性
4. **考虑使用Redisson**：开箱即用，功能完善
5. **加锁失败的处理**：重试 or 快速失败
