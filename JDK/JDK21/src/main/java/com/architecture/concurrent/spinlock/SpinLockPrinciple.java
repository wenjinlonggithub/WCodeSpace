package com.architecture.concurrent.spinlock;

/**
 * 自旋锁原理详解
 *
 * ==========================================
 * 一、什么是自旋锁？
 * ==========================================
 *
 * 自旋锁 (Spin Lock) 是一种基于忙等待（busy-waiting）的锁机制：
 * - 线程在获取锁失败时，不会立即阻塞（睡眠）
 * - 而是在一个循环中不断尝试获取锁（自旋）
 * - 直到获取成功或达到自旋次数上限
 *
 *
 * ==========================================
 * 二、自旋锁 vs 互斥锁
 * ==========================================
 *
 * ┌─────────────┬──────────────────┬──────────────────┐
 * │             │ 自旋锁           │ 互斥锁           │
 * ├─────────────┼──────────────────┼──────────────────┤
 * │ 获取失败    │ 循环等待(自旋)   │ 阻塞(睡眠)       │
 * │ CPU占用     │ 高(一直占用CPU)  │ 低(让出CPU)      │
 * │ 上下文切换  │ 无               │ 有(开销大)       │
 * │ 适用场景    │ 锁持有时间短     │ 锁持有时间长     │
 * │ 性能        │ 短临界区高       │ 长临界区高       │
 * └─────────────┴──────────────────┴──────────────────┘
 *
 *
 * ==========================================
 * 三、自旋锁的核心思想
 * ==========================================
 *
 * 传统互斥锁：
 *   线程A持有锁 → 线程B尝试获取 → 获取失败
 *       ↓
 *   线程B进入阻塞状态（睡眠）
 *       ↓

 *   发生用户态→内核态切换（开销大）
 *   切换原理：线程从用户态进入内核态，由操作系统进行线程调度和管理
 *   具体原因：需要操作系统介入进行线程阻塞和后续唤醒，确保系统资源合理分配
 *   切换步骤：用户态 -> 内核态 -> 系统调用 -> 线程阻塞 -> 等待锁释放 -> 唤醒 -> 用户态
 *       ↓
 *   线程A释放锁
 *       ↓
 *   唤醒线程B（内核态→用户态切换）
 *       ↓
 *   线程B获取锁
 *
 * 自旋锁：
 *   线程A持有锁 → 线程B尝试获取 → 获取失败
 *       ↓
 *   线程B在原地自旋（while循环）
 *       ↓
 *   不断尝试：lock() → lock() → lock() → ...
 *       ↓
 *   线程A释放锁
 *       ↓
 *   线程B立即获取到锁（无切换开销）
 *
 *
 * ==========================================
 * 四、自旋锁的基本实现
 * ==========================================
 *
 * public class SimpleSpinLock {
 *     private AtomicBoolean locked = new AtomicBoolean(false);
 *
 *     public void lock() {
 *         // 自旋：不断尝试将 false 改为 true
 *         while (!locked.compareAndSet(false, true)) {
 *             // 空循环，一直自旋
 *         }
 *     }
 *
 *     public void unlock() {
 *         locked.set(false);
 *     }
 * }
 *
 * 执行流程：
 * ┌────────────────────────────────────────┐
 * │ 初始状态: locked = false               │
 * └────────────────────────────────────────┘
 *           ↓
 * 线程A调用 lock():
 *   while (!locked.compareAndSet(false, true)) { }
 *         ↓
 *   CAS(false, true) 成功 → locked = true
 *         ↓
 *   线程A获取锁，进入临界区
 *
 * ┌────────────────────────────────────────┐
 * │ 此时: locked = true                    │
 * └────────────────────────────────────────┘
 *           ↓
 * 线程B调用 lock():
 *   while (!locked.compareAndSet(false, true)) {
 *         ↓
 *   CAS(false, true) 失败（locked已经是true）
 *         ↓
 *   继续循环: CAS → 失败 → CAS → 失败 → ...  ← 自旋
 *   }
 *         ↓
 * 线程A释放锁: locked.set(false)
 *         ↓
 * 线程B的下一次CAS成功: CAS(false, true) → 获取锁
 *
 *
 * ==========================================
 * 五、自旋锁的演进历史
 * ==========================================
 *
 * 1. 简单自旋锁 (Simple Spin Lock)
 *    - 无限自旋，可能永远获取不到锁
 *    - 存在公平性问题
 *
 * 2. 票据自旋锁 (Ticket Spin Lock)
 *    - 保证公平性（FIFO）
 *    - 每个线程拿号排队
 *
 * 3. 数组自旋锁 (Array-Based Queue Lock - MCS Lock)
 *    - 每个线程在不同的内存位置自旋
 *    - 避免缓存一致性问题
 *
 * 4. CLH 自旋锁 (Craig, Landin, and Hagersten Lock)
 *    - JDK AQS 的基础
 *    - 链表结构，每个线程在前驱节点上自旋
 *
 *
 * ==========================================
 * 六、JDK 中的自旋锁应用
 * ==========================================
 *
 * 1. synchronized 的自适应自旋
 *    - JDK 6+ 引入
 *    - 尝试自旋一定次数后再阻塞
 *    - 自适应：根据历史成功率调整自旋次数
 *
 * 2. AQS (AbstractQueuedSynchronizer)
 *    - tryAcquire() 失败后先自旋
 *    - 自旋一定次数后进入等待队列
 *
 * 3. ConcurrentHashMap
 *    - 在扩容时使用自旋等待
 *
 * 4. Atomic 类
 *    - 底层都是 CAS + 自旋
 *
 *
 * ==========================================
 * 七、自旋锁的优缺点
 * ==========================================
 *
 * 优点：
 * ✓ 避免线程阻塞和唤醒的开销
 * ✓ 无用户态/内核态切换
 * ✓ 适合锁持有时间极短的场景
 * ✓ 响应速度快
 *
 * 缺点：
 * ✗ 持续占用 CPU（空转）
 * ✗ 不适合单核 CPU（浪费时间片）
 * ✗ 不适合锁持有时间长的场景
 * ✗ 可能导致活锁
 *
 *
 * ==========================================
 * 八、自旋优化技术
 * ==========================================
 *
 * 1. 自适应自旋 (Adaptive Spinning)
 *    - 根据上次自旋成功率调整自旋次数
 *    - JVM 自动调整
 *
 * 2. 指数退避 (Exponential Backoff)
 *    while (!tryLock()) {
 *        Thread.onSpinWait();  // CPU 提示：我在自旋
 *        backoffTime *= 2;      // 退避时间指数增长
 *        sleep(backoffTime);
 *    }
 *
 * 3. 混合策略
 *    - 先自旋 N 次
 *    - 再使用 Thread.yield() 让出 CPU
 *    - 最后阻塞
 *
 *
 * ==========================================
 * 九、缓存一致性问题
 * ==========================================
 *
 * 简单自旋锁的问题：
 *
 * CPU0                CPU1                CPU2
 *   |                   |                   |
 * 持有锁              自旋                自旋
 *   |                   ↓                   ↓
 *   |          读 locked (缓存)    读 locked (缓存)
 *   |                   |                   |
 * 释放锁
 *   ↓
 * 写 locked = false
 *   |
 *   └─────→ 广播缓存失效 ─────→ CPU1/CPU2 缓存失效
 *                 ↓
 *         CPU1/CPU2 重新读取 locked
 *                 ↓
 *           缓存行争用（Cache Line Bouncing）
 *
 * 解决方案：MCS Lock / CLH Lock
 * - 每个线程在不同的内存位置自旋
 * - 避免缓存行争用
 *
 *
 * ==========================================
 * 十、何时使用自旋锁？
 * ==========================================
 *
 * 适合场景：
 * ✓ 临界区代码执行时间很短（几十纳秒到几微秒）
 * ✓ 多核 CPU 环境
 * ✓ 锁竞争不激烈
 * ✓ 对响应时间要求高
 *
 * 不适合场景：
 * ✗ 临界区代码执行时间长
 * ✗ 单核 CPU（浪费时间片）
 * ✗ 锁竞争激烈（多个线程同时竞争）
 * ✗ 可能在临界区内阻塞（IO 操作等）
 *
 * 经验法则：
 * - 临界区执行时间 < 2 次上下文切换时间 → 使用自旋锁
 * - 临界区执行时间 > 2 次上下文切换时间 → 使用互斥锁
 * - 上下文切换时间通常在 1-10 微秒
 *
 */
public class SpinLockPrinciple {

    public static void main(String[] args) {
        System.out.println("请查看本类的注释，了解自旋锁的完整原理！");
    }
}
