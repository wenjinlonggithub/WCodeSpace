package com.architecture.concurrent.countdownlatch;

/**
 * CountDownLatch 核心原理图解
 *
 * 本类用纯注释展示 CountDownLatch 的内部实现原理
 */
public class CountDownLatchPrinciple {

    /*
     * ==========================================
     *  一、整体架构
     * ==========================================
     *
     * CountDownLatch
     *     │
     *     ├── Sync (内部类, 继承 AQS)
     *     │     │
     *     │     ├── state (int, volatile) ← 存储计数器值
     *     │     ├── tryAcquireShared()    ← await() 调用
     *     │     └── tryReleaseShared()    ← countDown() 调用
     *     │
     *     ├── await()       → 阻塞等待计数器归零
     *     └── countDown()   → 计数器减1
     *
     *
     * ==========================================
     *  二、初始化流程
     * ==========================================
     *
     * CountDownLatch latch = new CountDownLatch(3);
     *
     * ┌─────────────────────────────────┐
     * │   CountDownLatch 对象           │
     * │                                 │
     * │   sync: Sync                    │
     * │     │                           │
     * │     └── state = 3  (volatile)   │ ← AQS 的 state 字段存储计数值
     * └─────────────────────────────────┘
     *
     *
     * ==========================================
     *  三、await() 执行流程
     * ==========================================
     *
     * 线程A: latch.await()
     *
     * 1. 调用 sync.acquireSharedInterruptibly(1)
     *        ↓
     * 2. 调用 tryAcquireShared(1)
     *        ↓
     *    return (getState() == 0) ? 1 : -1;
     *        ↓
     *    假设 state = 3 → 返回 -1 (获取失败)
     *        ↓
     * 3. 进入 AQS 等待队列 (CLH 队列)
     *        ↓
     * 4. LockSupport.park(this) ← 阻塞当前线程
     *
     *
     * ┌────────────────────────────────────────┐
     * │   AQS 等待队列 (双向链表)               │
     * │                                        │
     * │   Head ⇄ Node(线程A) ⇄ Node(线程B)     │
     * │              ↓                         │
     * │          WAITING (park)                │
     * └────────────────────────────────────────┘
     *
     *
     * ==========================================
     *  四、countDown() 执行流程（核心！）
     * ==========================================
     *
     * 线程B: latch.countDown()
     *
     * 1. 调用 sync.releaseShared(1)
     *        ↓
     * 2. 调用 tryReleaseShared(1)
     *
     *    protected boolean tryReleaseShared(int releases) {
     *        for (;;) {  // ← 自旋循环
     *
     *            int c = getState();        // 读取当前 state
     *            ┌────────────────┐
     *            │  读屏障保证     │
     *            │  看到最新值     │
     *            └────────────────┘
     *
     *            if (c == 0) return false;  // 已经是0，直接返回
     *
     *            int nextc = c - 1;         // 计算新值
     *
     *            // CAS 原子更新
     *            if (compareAndSetState(c, nextc)) {
     *                ┌─────────────────────────────────┐
     *                │  CPU 原子指令 cmpxchg           │
     *                │  if (state == c)                │
     *                │      state = nextc              │
     *                │      return true                │
     *                │  else                           │
     *                │      return false (重试)        │
     *                └─────────────────────────────────┘
     *
     *                return nextc == 0;  // 减到0返回true，否则false
     *            }
     *            // CAS 失败 → continue 自旋重试
     *        }
     *    }
     *
     * 3. 如果 tryReleaseShared() 返回 true (减到0)
     *        ↓
     *    调用 doReleaseShared() ← 唤醒等待队列中的所有线程
     *        ↓
     *    遍历等待队列，调用 LockSupport.unpark(线程)
     *        ↓
     *    所有等待线程被唤醒 → await() 返回
     *
     *
     * ==========================================
     *  五、完整时序图（3个线程并发 countDown）
     * ==========================================
     *
     * 时间线   线程A (await)        线程B (countDown)      线程C (countDown)      线程D (countDown)      state
     * ────────────────────────────────────────────────────────────────────────────────────────────────────────
     * t0                                                                                                    3
     * t1      await()
     *         → tryAcquireShared()
     *         → state=3 返回-1
     *         → 进入等待队列
     *         → park() 阻塞
     * ────────────────────────────────────────────────────────────────────────────────────────────────────────
     * t2                          countDown()
     *                             → tryReleaseShared()
     *                             → CAS: 3→2 成功                                                          2
     *                             → 返回 false (不唤醒)
     * ────────────────────────────────────────────────────────────────────────────────────────────────────────
     * t3                                                   countDown()
     *                                                      → tryReleaseShared()
     *                                                      → CAS: 2→1 成功                                1
     *                                                      → 返回 false (不唤醒)
     * ────────────────────────────────────────────────────────────────────────────────────────────────────────
     * t4                                                                           countDown()
     *                                                                              → tryReleaseShared()
     *                                                                              → CAS: 1→0 成功        0
     *                                                                              → 返回 true
     *                                                                              → doReleaseShared()
     *                                                                              → unpark(线程A)
     * ────────────────────────────────────────────────────────────────────────────────────────────────────────
     * t5      线程A被唤醒
     *         → await() 返回
     *         → 继续执行
     * ────────────────────────────────────────────────────────────────────────────────────────────────────────
     *
     *
     * ==========================================
     *  六、CAS 并发场景详解
     * ==========================================
     *
     * 假设线程B和线程C同时调用 countDown()，state = 2
     *
     * 线程B:                                    线程C:
     *   int c = getState();  // c = 2            int c = getState();  // c = 2
     *   int nextc = c - 1;   // nextc = 1        int nextc = c - 1;   // nextc = 1
     *
     *   compareAndSetState(2, 1)                 compareAndSetState(2, 1)
     *        ↓                                        ↓
     *   CPU 执行 cmpxchg:                        CPU 执行 cmpxchg:
     *   ┌─────────────────┐                      ┌─────────────────┐
     *   │ 线程B先执行:     │                      │ 线程C后执行:     │
     *   │ state == 2 √    │                      │ state == 1 ✗    │ ← state已被B改成1
     *   │ state = 1       │                      │ 返回 false      │
     *   │ 返回 true       │                      └─────────────────┘
     *   └─────────────────┘                             ↓
     *        ↓                                      continue; (自旋重试)
     *   返回 false (没减到0)                             ↓
     *                                              int c = getState();  // c = 1
     *                                              int nextc = c - 1;   // nextc = 0
     *                                              compareAndSetState(1, 0) → 成功!
     *                                              return true; (减到0，触发唤醒)
     *
     *
     * ==========================================
     *  七、为什么是一次性的？
     * ==========================================
     *
     * protected boolean tryReleaseShared(int releases) {
     *     for (;;) {
     *         int c = getState();
     *         if (c == 0) return false;  // ← 关键：state=0 后直接返回，不再修改
     *         // ...
     *     }
     * }
     *
     * state = 0 后：
     * - 再调用 countDown() → tryReleaseShared() 直接返回 false
     * - state 不会变成负数
     * - 无法重置计数器
     *
     * 如需可重用的计数器，使用 CyclicBarrier
     *
     *
     * ==========================================
     *  八、关键技术总结
     * ==========================================
     *
     * ┌─────────────────┬──────────────────────────────────────┐
     * │ 技术            │ 作用                                 │
     * ├─────────────────┼──────────────────────────────────────┤
     * │ AQS             │ 提供同步框架、等待队列、阻塞唤醒机制│
     * │ state (volatile)│ 存储计数器，保证可见性               │
     * │ CAS             │ 原子更新计数器，无锁并发             │
     * │ 自旋            │ CAS 失败时重试，避免阻塞             │
     * │ 共享模式        │ 一次唤醒所有等待线程                 │
     * │ CLH 队列        │ AQS 的等待队列，管理阻塞线程         │
     * │ LockSupport     │ park/unpark 实现线程阻塞和唤醒       │
     * └─────────────────┴──────────────────────────────────────┘
     *
     *
     * ==========================================
     *  九、性能分析
     * ==========================================
     *
     * 1. countDown() 性能：
     *    - 无锁操作（CAS）
     *    - O(1) 时间复杂度
     *    - 自旋次数取决于并发冲突程度
     *
     * 2. await() 性能：
     *    - state=0 时：O(1) 直接通过
     *    - state!=0 时：进入等待队列，阻塞开销
     *
     * 3. 唤醒性能：
     *    - 共享模式：一次性唤醒所有等待线程
     *    - 时间复杂度：O(n)，n = 等待线程数
     *
     *
     * ==========================================
     *  十、与其他同步器对比
     * ==========================================
     *
     * ┌──────────────┬────────────┬──────────┬──────────────┐
     * │              │ 可重用性   │ 方向     │ 典型场景     │
     * ├──────────────┼────────────┼──────────┼──────────────┤
     * │ CountDownLatch│ 一次性     │ 递减到0  │ 等待N个任务  │
     * │ CyclicBarrier │ 可重用     │ 累加到N  │ 多线程集合点 │
     * │ Semaphore     │ 可重用     │ 双向     │ 资源池控制   │
     * │ Phaser        │ 可重用     │ 多阶段   │ 复杂协调     │
     * └──────────────┴────────────┴──────────┴──────────────┘
     */

    public static void main(String[] args) {
        System.out.println("请查看本类的注释，了解 CountDownLatch 的完整实现原理！");
    }
}
