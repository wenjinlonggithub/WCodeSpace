🎭 故事背景：热门演唱会的售票大厅

想象一个超级火爆的演唱会售票现场，这就是AQS的世界！

第一幕：售票窗口的"状态牌"（State）

售票大厅有一个电子显示牌，上面显示着剩余票数，这就是AQS中的state变量：

┌─────────────────────┐
│  剩余票数: 1张     │  ← 这就是 state
└─────────────────────┘

在你的代码中体现：
- AQSBasicDemo.java:42 - compareAndSetState(0, 1) 就像 把显示牌从"1张票"改成"0张票"
- CustomLock.java:39 - getState() 就像查看显示牌上的数 字

第二幕：独占模式 - 单人VIP包厢（Exclusive Mode）

故事场景：
小明来到售票大厅，这里只有1个VIP包厢门票（state=1）：

时刻1: 小明冲进来
┌──────────┐
│ 显示牌   │
│ 票数: 1  │  → 小明看到有票！
└──────────┘

时刻2: 小明使用"闪电手"（CAS操作）
小明: "我要抢这张票！"
[CAS: 如果票数=1，就改成0，同时记下我的名字]
✓ 成功！显示牌变成 0，小明名字被记录

时刻3: 小红也冲进来
┌──────────┐
│ 显示牌   │
│ 票数: 0  │  → 小红看到没票了
│ 持有人:│
│ 小明     │
└──────────┘
小红: "啊，没票了，我得排队等..."

对应你的代码：
- AQSBasicDemo.java:42-45 - 小明的"闪电手"抢票操作
- CustomLock.java:44 - setExclusiveOwnerThread(current) 就是记录小明的名字

第三幕：等待队列 - 排队的艺术（CLH Queue）

当小红发现没票时，她不会傻站着，而是加入等待队列：

售票大厅的队伍（双向链表）:头节点(哨兵)
↓
[虚拟节点]← prev─┐
↓ next│
[小红的号码牌]───┘
状态: SIGNAL"前面的人走了要叫我！"
↓ next
[小刚的号码牌]
状态: SIGNAL
↓ next
null

队列的魔法规则：

1. 入队过程（小红加入队列）：
   // 对应 AQS 的 enq() 方法
   小红: "我要排队！"
   → 创建一个节点，写上自己的名字
   → 用CAS操作把自己接到队尾
   → 告诉前面的人："你走的时候叫我一声！"（设置前驱节点为SIGNAL状态）

2. 等待过程（小红在队列中）：
   // 对应 AQS 的 acquireQueued() 方法
   while (true) {
   if (我是队列第一个 && 尝试抢票成功) {
   拿票走人！
   break;
   }
   // 前面还有人，我先睡一觉
   park(); // 线程进入休眠，不占用CPU
   }

第四幕：释放锁 - 小明退票了！（Release）

小明看完演唱会信息后决定退票：

小明的退票过程:

1. 小明: "我要退票！"
   → 检查：是不是我持有的票？✓
   → 把显示牌改回1 (state = 1)
   → 清除持有人名字

2. 小明: "下一位！" (唤醒队列中的第一个人)
   → 找到队列头部的小红
   → unpark(小红) -叫醒小红

3. 小红醒来:
   → "轮到我了！"
   → 再次尝试 CAS 抢票
   → 成功！拿到票，从队列中移除

对应你的代码：
- CustomLock.java:62-74 - tryRelease() 就是小明的退票过程
- AQS内部的unparkSuccessor() -叫醒下一个人

第五幕：公平锁 vs 非公平锁

这是最精彩的部分！

非公平锁（默认模式）- 允许插队：

场景：小明刚退票，显示牌变成 1

时间线：
━━━━━━━━━━━━━━
小红(队列中): 😴 正在被唤醒中...
小李(新来的): 💨刚冲进大厅！

小李: "有票！我抢！"
[CAS: 0→1]✓ 成功！

小红: 😱 "我刚醒来票就没了？！"

对应代码：
// CustomLock.java:104-109- 非公平锁
if (compareAndSetState(0, 1))// 新来的直接抢！
setExclusiveOwnerThread(Thread.currentThread());   
else
acquire(1);  // 抢不到才排队

公平锁 - 严格排队：

场景：使用公平锁规则

小李(新来的): "有票！我要抢！"
门卫: "等等！前面有人排队，你得排到后面去！"

检查队列：
if (hasQueuedPredecessors()) {  // 有人在排队吗？      
return false;  // 不让抢，去排队！
}

对应代码：
// CustomLock.java:134-135 - 公平锁
if (!hasQueuedPredecessors() &&// 先检查有没有人排队   
compareAndSetState(0, acquires)) {
// 没人排队才能抢
}

让我继续讲解可重入性和共享模式...

第六幕：可重入锁 - 小明的多次进出

故事：
小明拿到票后，发现忘了拿宣传册，想再进来一次：

小明第一次:
state: 0→ 1
持有人: 小明
持有次数: 1

小明第二次进来:
门卫: "是你啊小明，进来吧！"
state: 1 → 2← 注意：不是变成0，而是累加！
持有次数: 2

小明第三次:
state: 2 → 3
持有次数: 3

小明退出时必须退3次:
第1次退出: state: 3 → 2 (还没完全释放)
第2次退出: state: 2 → 1 (还没完全释放)
第3次退出: state: 1 → 0 (完全释放！唤醒下一个人)

对应代码：
// CustomLock.java:47-53 - 可重入逻辑
else if (current == getExclusiveOwnerThread()) {       
// 是同一个人，允许再次进入
int nextc = c + acquires;  // 累加持有次数
setState(nextc);
return true;
}

第七幕：共享模式 - 多人会议室

前面讲的都是独占模式（一次只能一个人），现在讲共享模式 ：

场景：不是售票了，而是会议室预订
会议室容量: 5人(state = 5)

小明来了: state: 5 → 4✓ 进入
小红来了: state: 4 → 3 ✓ 进入
小刚来了: state: 3 → 2 ✓ 进入
小李来了: state: 2 → 1 ✓ 进入
小张来了: state: 1 → 0 ✓ 进入

小王来了: state: 0 → ✗ 满了！排队等待

小明离开: state: 0 → 1→唤醒队列中的小王
→ 小王进入！

关键区别：
- 独占模式：tryAcquire() / tryRelease() - 一次只能一个 线程
- 共享模式：tryAcquireShared() / tryReleaseShared() -  可以多个线程同时持有

让我用一个完整的流程图总结AQS的核心机制...

🎯 AQS核心工作流程总结

线程尝试获取锁的完整旅程:

开始↓
尝试获取锁 (tryAcquire)
↓
成功?──Yes──→拿到锁，开心地工作 ✓
↓No
↓
创建节点，加入等待队列 (enq)
↓
进入自旋检查循环 (acquireQueued)
↓
我是队列第一个吗?
↓
Yes → 再次尝试获取锁
↓         成功      失败
↓         ↓
出队      继续等待
↓         ↓
工作      park() 休眠 😴
↓
等待被唤醒...
↓
unpark() 被叫醒！
↓
回到循环，再次尝试

##🔑 核心要点对照表

| AQS概念  | 生动比喻             | 代码位置           
|
|----------|----------------------|-----------------------|
| state    | 电子显示牌的票数     | AQSBasicDemo.java:42  |
| CAS操作  | 闪电手抢票           | compareAndSetState()  |
| 独占模式 | VIP单人包厢          | tryAcquire()          |
| 共享模式 | 多人会议室           | tryAcquireShared()    |
| 等待队列 | 排队的队伍           | CLH双向链表           |
| park()   | 排队时打个盹         | 线程休眠           
|
| unpark() | 叫醒下一个人         | 唤醒线程           
|
| 公平锁   | 严格排队，不许插队   | CustomLock.java:134   |
| 非公平锁 | 允许插队抢票         | CustomLock.java:106   |
| 可重入   | 同一个人可以多次进出 | CustomLock.java:47-53 |

这个故事完整地展示了AQS的核心工作机制！你的代码中的每一都能在这个故事中找到对应的场景。
