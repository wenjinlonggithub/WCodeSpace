# 分布式事务面试题汇总

## 基础概念题

### 1. 什么是分布式事务？为什么需要分布式事务？

**答案：**
分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。

**需要分布式事务的场景：**
- 跨数据库的数据一致性问题
- 跨服务的业务一致性问题
- 跨系统的数据同步问题

**举例：**
用户下单场景，需要：
1. 订单服务创建订单
2. 库存服务扣减库存
3. 账户服务扣减余额
4. 积分服务增加积分

这四个操作分布在不同的服务和数据库中，需要保证要么全部成功，要么全部失败。

---

### 2. CAP理论和BASE理论是什么？

**CAP理论：**
- **C (Consistency)**: 一致性 - 所有节点在同一时间看到相同的数据
- **A (Availability)**: 可用性 - 每个请求都能得到响应（成功或失败）
- **P (Partition Tolerance)**: 分区容错性 - 系统在网络分区时仍能继续工作

**重要结论：** 三者只能同时满足两个，分布式系统必须选择P，所以只能在C和A之间权衡。

**BASE理论：**
- **BA (Basically Available)**: 基本可用
- **S (Soft State)**: 软状态 - 允许系统中的数据存在中间状态
- **E (Eventually Consistent)**: 最终一致性

BASE是对CAP中一致性和可用性权衡的结果，通过牺牲强一致性来获得可用性。

---

### 3. 强一致性、弱一致性、最终一致性的区别？

**强一致性：**
- 任何时刻，所有节点的数据都是一致的
- 写操作完成后，任何后续读操作都能读到最新值
- 例如：2PC、3PC

**弱一致性：**
- 系统不保证后续访问能返回最新值
- 例如：DNS系统

**最终一致性：**
- 系统保证在没有新的更新的情况下，最终所有访问都能返回最新值
- 不保证多久之后达到一致
- 例如：TCC、Saga、消息队列

---

## 分布式事务解决方案

### 4. 2PC（两阶段提交）的原理是什么？有什么优缺点？

**原理：**

**第一阶段（准备阶段）：**
1. 协调者向所有参与者发送Prepare请求
2. 参与者执行事务操作但不提交，记录undo和redo日志
3. 参与者向协调者返回Yes或No

**第二阶段（提交阶段）：**
- 如果所有参与者都返回Yes：
  - 协调者发送Commit请求
  - 参与者提交事务并释放资源
- 如果有参与者返回No：
  - 协调者发送Rollback请求
  - 参与者回滚事务并释放资源

**优点：**
- 强一致性保证
- 实现相对简单

**缺点：**
1. **同步阻塞**：参与者在等待协调者指令时会阻塞
2. **单点故障**：协调者故障会导致整个系统不可用
3. **数据不一致**：在第二阶段，如果协调者发送commit后崩溃，部分参与者收到commit，部分未收到
4. **性能问题**：资源锁定时间长

---

### 5. 3PC（三阶段提交）相比2PC有什么改进？

**三个阶段：**

**第一阶段（CanCommit）：**
- 协调者询问参与者是否可以执行事务
- 参与者返回Yes或No（不执行事务）

**第二阶段（PreCommit）：**
- 如果都返回Yes，协调者发送PreCommit
- 参与者执行事务但不提交，返回ACK

**第三阶段（DoCommit）：**
- 协调者发送Commit或Abort
- 参与者提交或回滚

**改进点：**
1. **引入超时机制**：参与者等待超时后自动提交（假设其他参与者也成功）
2. **降低阻塞范围**：CanCommit阶段不执行事务，减少资源锁定时间
3. **增加PreCommit阶段**：让参与者做好准备

**仍存在的问题：**
- 网络分区时可能导致数据不一致
- 性能仍然不高

---

### 6. TCC（Try-Confirm-Cancel）的原理和实现要点？

**三个阶段：**

**Try阶段：**
- 尝试执行业务
- 完成所有业务检查（一致性）
- 预留必须的业务资源（准隔离性）

**Confirm阶段：**
- 真正执行业务
- 不做任何业务检查
- 只使用Try阶段预留的业务资源
- Confirm操作必须满足幂等性

**Cancel阶段：**
- 释放Try阶段预留的业务资源
- Cancel操作必须满足幂等性

**实现要点：**

1. **幂等性设计**
```java
// 使用唯一业务ID防止重复执行
if (isExecuted(transactionId)) {
    return;
}
executeBusinessLogic();
markAsExecuted(transactionId);
```

2. **资源预留**
```java
// Try阶段：冻结金额而不是直接扣减
account.frozenAmount += amount;
account.availableAmount -= amount;

// Confirm阶段：真正扣减
account.frozenAmount -= amount;
account.totalAmount -= amount;

// Cancel阶段：解冻
account.frozenAmount -= amount;
account.availableAmount += amount;
```

3. **空回滚处理**
- Try未执行，直接执行Cancel
- 需要记录事务状态

4. **悬挂处理**
- Cancel先于Try执行
- 需要记录Cancel状态，Try执行时检查

**优点：**
- 性能较好，不长时间锁定资源
- 最终一致性

**缺点：**
- 业务侵入性强
- 实现复杂度高

---

### 7. Saga模式的原理和适用场景？

**原理：**
Saga将长事务拆分为多个本地短事务，每个本地事务都有对应的补偿事务。如果某个本地事务失败，则执行之前所有成功事务的补偿操作。

**两种实现方式：**

**1. 事件编排（Choreography）：**
- 没有中央协调器
- 每个服务监听事件并决定下一步操作
- 去中心化

**2. 命令协调（Orchestration）：**
- 有中央协调器
- 协调器负责调用各个服务
- 中心化

**执行流程：**
```
正向流程：T1 -> T2 -> T3 -> T4
补偿流程：C4 -> C3 -> C2 -> C1
```

**适用场景：**
- 长流程业务（订单处理、旅游预订）
- 对一致性要求不是特别严格
- 子事务可以补偿

**优点：**
- 一阶段提交，性能好
- 实现相对简单

**缺点：**
- 不保证隔离性（可能读到中间状态）
- 需要设计补偿逻辑

---

### 8. 本地消息表方案的原理？

**原理：**
利用本地事务保证业务操作和消息发送的原子性。

**实现步骤：**

1. **发送方：**
```sql
BEGIN TRANSACTION;
-- 执行业务操作
INSERT INTO orders VALUES (...);
-- 插入消息表
INSERT INTO message_table VALUES (msg_id, content, status='PENDING');
COMMIT;

-- 定时任务扫描消息表，发送消息到MQ
-- 发送成功后更新状态为'SENT'
```

2. **接收方：**
```java
// 消费消息
@Transactional
public void handleMessage(Message msg) {
    // 幂等性检查
    if (isProcessed(msg.getId())) {
        return;
    }
    // 执行业务逻辑
    processBusinessLogic(msg);
    // 记录已处理
    markAsProcessed(msg.getId());
}
```

**优点：**
- 实现简单
- 不依赖第三方组件

**缺点：**
- 业务耦合
- 需要额外的消息表

---

### 9. 可靠消息最终一致性方案（RocketMQ事务消息）？

**原理：**
利用消息队列的事务消息功能，保证本地事务和消息发送的一致性。

**执行流程：**

1. **发送Half消息**
```java
// 发送半消息（对消费者不可见）
transactionMQProducer.sendMessageInTransaction(msg, localTransactionExecutor);
```

2. **执行本地事务**
```java
public LocalTransactionState executeLocalTransaction(Message msg, Object arg) {
    try {
        // 执行本地事务
        executeBusinessLogic();
        return LocalTransactionState.COMMIT_MESSAGE;
    } catch (Exception e) {
        return LocalTransactionState.ROLLBACK_MESSAGE;
    }
}
```

3. **消息回查**
```java
public LocalTransactionState checkLocalTransaction(MessageExt msg) {
    // 查询本地事务状态
    TransactionStatus status = queryTransactionStatus(msg.getTransactionId());
    if (status == SUCCESS) {
        return LocalTransactionState.COMMIT_MESSAGE;
    } else if (status == FAILED) {
        return LocalTransactionState.ROLLBACK_MESSAGE;
    }
    return LocalTransactionState.UNKNOW;
}
```

**优点：**
- 性能好
- 最终一致性保证

**缺点：**
- 依赖MQ
- 只能保证最终一致性

---

### 10. Seata的AT模式原理？

**原理：**
基于本地ACID事务，通过自动生成反向SQL实现自动补偿。

**执行流程：**

**第一阶段：**
1. 解析SQL，查询前镜像（before image）
2. 执行业务SQL
3. 查询后镜像（after image）
4. 生成行锁
5. 提交本地事务
6. 上报执行结果

**第二阶段：**
- **提交**：删除前后镜像和行锁
- **回滚**：用前镜像恢复数据，删除后镜像和行锁

**示例：**
```sql
-- 业务SQL
UPDATE account SET balance = balance - 100 WHERE id = 1;

-- Seata自动记录
Before Image: {id: 1, balance: 1000}
After Image: {id: 1, balance: 900}

-- 回滚时自动生成
UPDATE account SET balance = 1000 WHERE id = 1;
```

**优点：**
- 对业务无侵入
- 自动补偿

**缺点：**
- 只支持关系型数据库
- 存在脏读问题（需要全局锁）

---

## 高级问题

### 11. 如何保证分布式事务的幂等性？

**幂等性定义：**
同一个操作执行多次和执行一次的效果相同。

**实现方案：**

**1. 唯一ID + 去重表**
```java
@Transactional
public void processOrder(String orderId) {
    // 检查是否已处理
    if (deduplicationTable.exists(orderId)) {
        return;
    }
    // 执行业务逻辑
    createOrder(orderId);
    // 记录已处理
    deduplicationTable.insert(orderId);
}
```

**2. 状态机**
```java
public void updateOrderStatus(String orderId, OrderStatus newStatus) {
    Order order = getOrder(orderId);
    // 只有当前状态允许时才更新
    if (order.canTransitionTo(newStatus)) {
        order.setStatus(newStatus);
        updateOrder(order);
    }
}
```

**3. 乐观锁**
```sql
UPDATE orders
SET status = 'PAID', version = version + 1
WHERE order_id = ? AND version = ?;
```

**4. 分布式锁**
```java
public void processPayment(String orderId) {
    String lockKey = "payment:" + orderId;
    if (redisLock.tryLock(lockKey)) {
        try {
            // 执行业务逻辑
            doPayment(orderId);
        } finally {
            redisLock.unlock(lockKey);
        }
    }
}
```

---

### 12. 分布式事务中如何处理超时？

**超时场景：**
1. 网络超时
2. 服务响应慢
3. 死锁

**处理策略：**

**1. 设置合理的超时时间**
```java
@GlobalTransactional(timeoutMills = 60000)
public void businessMethod() {
    // 业务逻辑
}
```

**2. 超时后的处理**
```java
try {
    Future<Result> future = executor.submit(task);
    Result result = future.get(5, TimeUnit.SECONDS);
} catch (TimeoutException e) {
    // 超时处理
    future.cancel(true);
    // 执行补偿逻辑
    compensate();
}
```

**3. 重试机制**
```java
@Retryable(
    value = {TimeoutException.class},
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000)
)
public void retryableMethod() {
    // 业务逻辑
}
```

**4. 熔断降级**
```java
@HystrixCommand(
    fallbackMethod = "fallback",
    commandProperties = {
        @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000")
    }
)
public Result businessMethod() {
    // 业务逻辑
}

public Result fallback() {
    // 降级逻辑
    return defaultResult();
}
```

---

### 13. 如何选择合适的分布式事务方案？

**决策树：**

```
是否需要强一致性？
├─ 是 → 2PC/3PC（性能差，不推荐）
└─ 否 → 可接受最终一致性
    ├─ 业务可补偿？
    │   ├─ 是 → 长流程？
    │   │   ├─ 是 → Saga
    │   │   └─ 否 → TCC
    │   └─ 否 → 可靠消息
    └─ 对业务侵入性要求？
        ├─ 低 → Seata AT模式
        └─ 可接受 → TCC
```

**场景推荐：**

| 场景 | 推荐方案 | 原因 |
|------|---------|------|
| 电商下单 | Seata AT / TCC | 需要保证库存、订单、支付一致 |
| 转账 | 2PC / TCC | 强一致性要求 |
| 订单流程 | Saga | 长流程，可补偿 |
| 数据同步 | 可靠消息 | 异步，最终一致 |
| 微服务调用 | Seata | 对业务侵入小 |

---

### 14. 分布式事务的性能优化方案？

**1. 减少事务范围**
```java
// 不好的做法：事务范围太大
@GlobalTransactional
public void processOrder() {
    createOrder();        // 需要事务
    sendEmail();         // 不需要事务
    updateStatistics();  // 不需要事务
}

// 好的做法：只在必要的地方使用事务
public void processOrder() {
    createOrderWithTransaction();
    asyncSendEmail();
    asyncUpdateStatistics();
}
```

**2. 异步化**
```java
// 同步调用
@GlobalTransactional
public void createOrder() {
    orderService.create();
    inventoryService.deduct();  // 同步调用
    pointService.add();         // 同步调用
}

// 异步化
public void createOrder() {
    orderService.create();
    // 发送消息，异步处理
    mqProducer.send(new OrderCreatedEvent());
}
```

**3. 批量处理**
```java
// 逐条处理
for (Order order : orders) {
    processOrder(order);  // 每次都开启事务
}

// 批量处理
@GlobalTransactional
public void batchProcessOrders(List<Order> orders) {
    // 一次事务处理多条
    orderService.batchCreate(orders);
}
```

**4. 读写分离**
```java
// 读操作不参与分布式事务
public Order queryOrder(String orderId) {
    return orderMapper.selectById(orderId);  // 从读库查询
}

// 写操作参与分布式事务
@GlobalTransactional
public void updateOrder(Order order) {
    orderMapper.updateById(order);  // 写主库
}
```

---

### 15. 实际项目中遇到的分布式事务问题及解决方案？

**问题1：TCC空回滚**

**场景：**
Try阶段因网络超时未执行，但Cancel被调用。

**解决方案：**
```java
public void cancel(String transactionId) {
    // 检查Try是否执行
    TransactionRecord record = getTransactionRecord(transactionId);
    if (record == null) {
        // 空回滚，记录状态但不执行业务逻辑
        insertTransactionRecord(transactionId, "CANCELLED");
        return;
    }
    // 正常回滚
    doCancel(record);
}
```

**问题2：Saga补偿失败**

**场景：**
补偿操作执行失败，导致数据不一致。

**解决方案：**
```java
public void compensate(String transactionId) {
    int retryCount = 0;
    while (retryCount < MAX_RETRY) {
        try {
            doCompensate(transactionId);
            return;
        } catch (Exception e) {
            retryCount++;
            if (retryCount >= MAX_RETRY) {
                // 记录到失败表，人工介入
                recordFailedCompensation(transactionId, e);
                alertAdmin(transactionId);
            }
            Thread.sleep(1000 * retryCount);  // 指数退避
        }
    }
}
```

**问题3：消息重复消费**

**场景：**
MQ消息被重复消费，导致业务重复执行。

**解决方案：**
```java
@Transactional
public void handleMessage(Message msg) {
    String messageId = msg.getId();
    // 幂等性检查
    if (messageProcessedTable.exists(messageId)) {
        log.info("Message already processed: {}", messageId);
        return;
    }
    // 执行业务逻辑
    processBusinessLogic(msg);
    // 记录已处理
    messageProcessedTable.insert(messageId, new Date());
}
```

---

## 总结

分布式事务是分布式系统中的核心问题，需要根据业务场景选择合适的方案：

1. **强一致性场景**：2PC/3PC（不推荐）或同步调用
2. **最终一致性场景**：TCC、Saga、可靠消息、Seata
3. **性能要求高**：TCC、Saga、异步消息
4. **实现简单**：Seata AT模式、可靠消息

**关键点：**
- 幂等性设计
- 超时处理
- 补偿机制
- 监控告警
- 人工介入机制
