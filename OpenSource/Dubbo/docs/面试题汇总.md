# Dubbo 面试题汇总

## 目录

1. [基础篇](#基础篇)
2. [架构篇](#架构篇)
3. [原理篇](#原理篇)
4. [性能篇](#性能篇)
5. [实战篇](#实战篇)
6. [高级篇](#高级篇)

---

## 基础篇

### 1. 什么是 Dubbo？

**答案**:

Dubbo 是阿里巴巴开源的高性能、轻量级的 Java RPC 框架。

**核心功能**:
- **远程方法调用**: 像调用本地方法一样调用远程服务
- **智能负载均衡**: 内置多种负载均衡策略
- **服务自动注册与发现**: 基于注册中心的服务发现机制
- **高度可扩展**: 基于 SPI 机制，所有核心能力都可扩展
- **运行时流量调度**: 动态配置规则，实现灰度发布等功能
- **可视化服务治理**: 提供监控和管理工具

---

### 2. Dubbo 和 Spring Cloud 的区别？

**答案**:

| 对比项 | Dubbo | Spring Cloud |
|-------|-------|--------------|
| 通信协议 | Dubbo 协议（TCP） | HTTP/REST |
| 性能 | 高性能 | 相对较低 |
| 服务注册 | Zookeeper/Nacos | Eureka/Consul |
| 负载均衡 | 客户端 | 服务端（Ribbon） |
| 服务调用 | RPC | REST API |
| 社区 | 阿里巴巴 | Spring 社区 |
| 生态 | 相对精简 | 完整生态 |

**选择建议**:
- **性能要求高**: 选择 Dubbo
- **快速开发**: 选择 Spring Cloud
- **混合使用**: Spring Cloud Alibaba（结合两者优点）

---

### 3. Dubbo 支持哪些协议？

**答案**:

1. **dubbo**: 默认协议，单一长连接，NIO 异步通信
   - 适用场景: 小数据量大并发的服务调用
   - 传输协议: TCP
   - 序列化: Hessian2

2. **rmi**: Java 标准的远程调用协议
   - 传输协议: TCP/IP
   - 序列化: Java 原生序列化

3. **hessian**: Hessian 的远程调用协议
   - 传输协议: HTTP
   - 序列化: Hessian 二进制序列化

4. **http**: 基于 HTTP 表单的远程调用协议
   - 传输协议: HTTP
   - 序列化: 表单序列化

5. **rest**: 支持 RESTful 调用
   - 传输协议: HTTP
   - 序列化: JSON/XML

6. **webservice**: 支持 SOAP 协议
   - 传输协议: HTTP
   - 序列化: SOAP XML

7. **thrift**: Apache Thrift 协议
8. **grpc**: Google gRPC 协议

---

### 4. Dubbo 支持哪些注册中心？

**答案**:

1. **Zookeeper**: Apache 官方推荐
   - 优点: 成熟稳定、功能完善
   - 缺点: 部署复杂、性能一般

2. **Nacos**: 阿里巴巴推荐
   - 优点: 配置中心 + 注册中心、性能好
   - 缺点: 相对较新

3. **Redis**: 高性能缓存
   - 优点: 性能极高
   - 缺点: 可靠性依赖持久化配置

4. **Multicast**: 组播
   - 优点: 无需第三方服务
   - 缺点: 仅适合开发测试

5. **Simple**: 简单注册中心
   - 优点: 标准 RPC 服务
   - 缺点: 单点故障

6. **Consul**: HashiCorp 产品
7. **Etcd**: CoreOS 产品

---

## 架构篇

### 5. Dubbo 的架构是怎样的？

**答案**:

```
┌─────────────┐      ┌─────────────┐
│  Consumer   │      │  Provider   │
│  (消费者)   │      │ (提供者)    │
└──────┬──────┘      └──────┬──────┘
       │  0. start          │  0. start
       │                    │
       │                    ▼  1. register
       │             ┌─────────────┐
       │             │  Registry   │
       │             │ (注册中心)   │
       │             └──────┬──────┘
       │  2. subscribe      │
       ├────────────────────┘
       │  3. notify
       │
       ▼  4. invoke
┌─────────────┐
│   Monitor   │  5. count
│  (监控中心)  │
└─────────────┘
```

**调用流程**:
1. Provider 启动时向 Registry 注册服务
2. Consumer 启动时向 Registry 订阅服务
3. Registry 返回 Provider 列表，如有变更推送通知
4. Consumer 从 Provider 列表中基于负载均衡选一台发起调用
5. Consumer 和 Provider 定时向 Monitor 发送统计信息

---

### 6. Dubbo 的分层架构？

**答案**:

```
┌─────────────────────────────────────────┐
│         Service (业务层)                 │
├─────────────────────────────────────────┤
│         Config (配置层)                  │
├─────────────────────────────────────────┤
│         Proxy (代理层)                   │
├─────────────────────────────────────────┤
│         Registry (注册层)                │
├─────────────────────────────────────────┤
│         Cluster (路由层)                 │
├─────────────────────────────────────────┤
│         Monitor (监控层)                 │
├─────────────────────────────────────────┤
│         Protocol (远程调用层)             │
├─────────────────────────────────────────┤
│         Exchange (信息交换层)             │
├─────────────────────────────────────────┤
│         Transport (网络传输层)            │
├─────────────────────────────────────────┤
│         Serialize (数据序列化层)          │
└─────────────────────────────────────────┘
```

**各层职责**:
- **Service**: 业务接口层
- **Config**: 配置管理层
- **Proxy**: 服务代理层，生成客户端 Stub 和服务端 Skeleton
- **Registry**: 服务注册层
- **Cluster**: 路由和负载均衡层
- **Monitor**: 监控统计层
- **Protocol**: 远程调用层
- **Exchange**: 信息交换层，封装请求响应模式
- **Transport**: 网络传输层，抽象 Netty 和 Mina 为统一接口
- **Serialize**: 数据序列化层

---

## 原理篇

### 7. Dubbo 的 SPI 机制是什么？

**答案**:

Dubbo SPI 是对 Java SPI 的增强，具有以下特性：

**Java SPI 的问题**:
- 一次性加载所有实现类，浪费资源
- 不支持按需加载
- 获取扩展类方式不够灵活
- 不支持依赖注入和 AOP

**Dubbo SPI 的优势**:
- **按需加载**: 只加载需要的扩展实现
- **依赖注入**: 支持扩展点之间的依赖注入
- **AOP 支持**: 支持包装类（Wrapper）进行 AOP 增强
- **自适应扩展**: 运行时根据参数动态选择扩展实现

**使用示例**:
```java
// 1. 定义扩展点接口
@SPI("dubbo")
public interface Protocol {
    <T> Exporter<T> export(Invoker<T> invoker);
}

// 2. 配置文件 META-INF/dubbo/org.apache.dubbo.rpc.Protocol
dubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol
http=org.apache.dubbo.rpc.protocol.http.HttpProtocol

// 3. 获取扩展实现
Protocol protocol = ExtensionLoader
    .getExtensionLoader(Protocol.class)
    .getExtension("dubbo");
```

---

### 8. Dubbo 的服务暴露过程？

**答案**:

```
Service Implementation
        ↓
  ProxyFactory.getInvoker()  // 包装为 Invoker
        ↓
  Protocol.export()          // 暴露服务
        ↓
  ┌──────────────────┐
  │  启动 Netty     │      // 启动服务器
  │  监听端口       │
  └──────────────────┘
        ↓
  Registry.register()        // 注册到注册中心
        ↓
  等待消费者调用
```

**详细步骤**:

1. **服务实现包装为 Invoker**
```java
Invoker<?> invoker = proxyFactory.getInvoker(ref, interfaceClass, url);
```

2. **导出服务**
```java
Exporter<?> exporter = protocol.export(invoker);
```

3. **启动服务器**
   - 创建 Netty Server
   - 绑定端口（如 20880）
   - 注册处理器

4. **注册到注册中心**
```java
registry.register(url);
```

5. **等待调用**

---

### 9. Dubbo 的服务引用过程？

**答案**:

```
Consumer 启动
        ↓
  Registry.subscribe()       // 订阅服务
        ↓
  接收 Provider 列表
        ↓
  创建 Invoker              // 为每个 Provider 创建 Invoker
        ↓
  Cluster.join()            // 集群容错
        ↓
  ProxyFactory.getProxy()   // 创建代理对象
        ↓
  返回服务引用
```

**详细步骤**:

1. **订阅服务**
```java
List<URL> urls = registry.lookup(url);
registry.subscribe(url, listener);
```

2. **创建 Invoker**
```java
Invoker<?> invoker = protocol.refer(interfaceClass, url);
```

3. **集群容错**
```java
Invoker<?> invoker = cluster.join(directory);
```

4. **创建代理**
```java
T proxy = proxyFactory.getProxy(invoker);
```

5. **返回代理对象给应用使用**

---

### 10. Dubbo 的调用流程？

**答案**:

```
Consumer 端:
1. 业务代码调用
        ↓
2. Proxy (代理拦截)
        ↓
3. InvokerInvocationHandler
        ↓
4. MockClusterInvoker (Mock 处理)
        ↓
5. AbstractClusterInvoker (集群容错)
        ↓
6. Directory (目录服务)
        ↓
7. Router (路由筛选)
        ↓
8. LoadBalance (负载均衡)
        ↓
9. Filter Chain (过滤器链)
        ↓
10. DubboInvoker (远程调用)
        ↓
11. 序列化请求
        ↓
12. Netty 发送请求

═══════════════════════════════

Provider 端:
13. Netty 接收请求
        ↓
14. 反序列化请求
        ↓
15. Filter Chain (过滤器链)
        ↓
16. DubboProtocol.reply()
        ↓
17. Invoker.invoke()
        ↓
18. Proxy.invoke() (代理调用)
        ↓
19. 真实服务实现
        ↓
20. 返回结果
        ↓
21. 序列化响应
        ↓
22. Netty 发送响应

═══════════════════════════════

Consumer 端:
23. Netty 接收响应
        ↓
24. 反序列化响应
        ↓
25. 唤醒等待的线程
        ↓
26. 返回结果给业务代码
```

---

### 11. Dubbo 的负载均衡策略有哪些？

**答案**:

1. **Random (随机，默认)**
   - 随机选择一个提供者
   - 支持权重，权重越大被选中的概率越高

```java
int totalWeight = 0;
for (Invoker invoker : invokers) {
    totalWeight += invoker.getWeight();
}
int offset = random.nextInt(totalWeight);
```

2. **RoundRobin (轮询)**
   - 轮流选择每个提供者
   - 支持权重，平滑加权轮询算法

```java
每个 Invoker 都有一个 current 权重
选择 current 最大的
被选中的 current -= totalWeight
所有 current += weight
```

3. **LeastActive (最少活跃调用数)**
   - 选择活跃调用数最少的提供者
   - 活跃调用数：正在处理的请求数量

4. **ConsistentHash (一致性哈希)**
   - 相同参数的请求总是发到同一提供者
   - 适用于有状态服务

5. **ShortestResponse (最短响应时间)**
   - 选择平均响应时间最短的提供者
   - Dubbo 2.7+ 新增

**配置方式**:
```xml
<dubbo:reference interface="UserService"
                 loadbalance="roundrobin" />
```

---

### 12. Dubbo 的集群容错策略有哪些？

**答案**:

1. **Failover (失败自动切换，默认)**
   - 失败后重试其他服务器
   - 适用于幂等操作（查询）
   - retries 配置重试次数

2. **Failfast (快速失败)**
   - 只发起一次调用，失败立即报错
   - 适用于非幂等操作（新增记录）

3. **Failsafe (失败安全)**
   - 出现异常时忽略
   - 适用于写入审计日志等操作

4. **Failback (失败自动恢复)**
   - 失败后后台记录请求，定时重发
   - 适用于消息通知操作

5. **Forking (并行调用)**
   - 并行调用多个服务器，只要一个成功即返回
   - forks 配置并行数
   - 适用于实时性要求高的读操作

6. **Broadcast (广播调用)**
   - 逐个调用所有提供者，任意一个报错则报错
   - 适用于通知所有提供者更新缓存或日志

7. **Available (可用优先)**
   - 遍历所有服务提供者，找到第一个可用的
   - 不进行负载均衡

**配置方式**:
```xml
<dubbo:reference interface="UserService"
                 cluster="failfast"
                 retries="0" />
```

---

## 性能篇

### 13. 如何优化 Dubbo 性能？

**答案**:

**1. 序列化优化**
```xml
<!-- 使用高性能序列化 -->
<dubbo:protocol name="dubbo" serialization="kryo" />
```

性能对比：Kryo > FST > Hessian2 > JSON > Java

**2. 连接优化**
```xml
<!-- 使用长连接 -->
<dubbo:protocol name="dubbo" connections="1" />

<!-- 增加连接数 -->
<dubbo:reference interface="UserService" connections="2" />
```

**3. 线程池优化**
```xml
<dubbo:protocol name="dubbo"
                threads="500"
                threadpool="fixed"
                queues="0" />
```

**4. 异步调用**
```xml
<dubbo:reference interface="UserService">
    <dubbo:method name="findUser" async="true" />
</dubbo:reference>
```

**5. 结果缓存**
```xml
<dubbo:reference interface="UserService"
                 cache="lru" />
```

**6. 预热**
```xml
<dubbo:service interface="UserService"
               warmup="600000" />
```

**7. 批量调用**
```java
// 减少调用次数
List<User> users = userService.batchGet(userIds);
```

---

### 14. Dubbo 如何处理超时？

**答案**:

**超时配置**:
```xml
<!-- 全局超时 -->
<dubbo:consumer timeout="3000" />

<!-- 接口级超时 -->
<dubbo:reference interface="UserService" timeout="5000" />

<!-- 方法级超时 -->
<dubbo:reference interface="UserService">
    <dubbo:method name="findUser" timeout="1000" />
</dubbo:reference>
```

**超时处理机制**:

1. **Consumer 端**:
   - 发起调用时启动定时器
   - 到达超时时间抛出 TimeoutException
   - 不会取消 Provider 端的执行

2. **Provider 端**:
   - 继续执行，直到完成或异常
   - 执行完成后发现 Consumer 已超时，丢弃结果

**超时配置优先级**:
```
方法级 > 接口级 > 全局配置
Consumer > Provider
```

**最佳实践**:
- 读操作：1-3秒
- 写操作：3-10秒
- 根据实际情况调整

---

## 实战篇

### 15. 如何保证 Dubbo 调用的幂等性？

**答案**:

**什么是幂等性**:
- 同一个请求执行多次和执行一次的效果相同

**实现方案**:

**1. 全局唯一 ID**
```java
public interface OrderService {
    void createOrder(String requestId, Order order);
}

// 使用 Redis 保存已处理的 requestId
if (redis.exists(requestId)) {
    return;  // 已处理，直接返回
}
// 处理业务
redis.setex(requestId, 3600, "1");
```

**2. 数据库唯一约束**
```sql
CREATE UNIQUE INDEX idx_order_no ON orders(order_no);
```

**3. Token 机制**
```java
// 获取 token
String token = orderService.getToken();

// 提交订单时携带 token
orderService.createOrder(token, order);

// 服务端验证 token
if (!tokenService.validate(token)) {
    throw new DuplicateRequestException();
}
tokenService.remove(token);
```

**4. 状态机**
```java
// 订单状态流转
INIT -> PROCESSING -> SUCCESS
       ↓
     FAILED

// 根据当前状态判断是否允许操作
if (order.getStatus() != OrderStatus.INIT) {
    return;  // 非初始状态，不处理
}
```

---

### 16. Dubbo 如何实现服务降级？

**答案**:

**1. Mock 降级**
```xml
<!-- 配置 Mock 返回值 -->
<dubbo:reference interface="UserService"
                 mock="return null" />

<!-- Mock 异常 -->
<dubbo:reference interface="UserService"
                 mock="throw" />

<!-- Mock 类 -->
<dubbo:reference interface="UserService"
                 mock="com.example.UserServiceMock" />
```

```java
public class UserServiceMock implements UserService {
    @Override
    public User getUserById(Long id) {
        // 返回默认用户或缓存数据
        return getDefaultUser();
    }
}
```

**2. 容错降级**
```java
try {
    return userService.getUserById(id);
} catch (RpcException e) {
    // 降级处理
    return getUserFromCache(id);
}
```

**3. 限流降级（集成 Sentinel）**
```java
@SentinelResource(value = "getUserById",
                  fallback = "getUserByIdFallback")
public User getUserById(Long id) {
    return userService.getUserById(id);
}

public User getUserByIdFallback(Long id, Throwable ex) {
    return getDefaultUser();
}
```

**4. 动态降级**
```bash
# 通过 QoS 命令动态配置
telnet 127.0.0.1 22222
mock com.example.UserService return null
```

---

### 17. Dubbo 如何实现灰度发布？

**答案**:

**方案1: 基于版本号**
```xml
<!-- 灰度版本 -->
<dubbo:service interface="UserService" version="2.0-gray" />

<!-- 稳定版本 -->
<dubbo:service interface="UserService" version="1.0" />

<!-- Consumer 选择版本 -->
<dubbo:reference interface="UserService" version="2.0-gray" />
```

**方案2: 基于标签路由**
```xml
<!-- Provider 打标签 -->
<dubbo:service interface="UserService" tag="gray" />

<!-- Consumer 指定标签 -->
<dubbo:reference interface="UserService">
    <dubbo:parameter key="dubbo.tag" value="gray" />
</dubbo:reference>
```

**方案3: 基于路由规则**
```yaml
# 条件路由规则
condition://0.0.0.0/com.example.UserService?
  category=routers&
  dynamic=true&
  rule=
    => host != 192.168.1.100
    host = 192.168.1.100 => host = 192.168.1.101
```

**方案4: 基于权重**
```xml
<!-- 灰度环境权重低 -->
<dubbo:service interface="UserService" weight="10" />

<!-- 生产环境权重高 -->
<dubbo:service interface="UserService" weight="90" />
```

---

### 18. Dubbo 如何实现分布式事务？

**答案**:

Dubbo 本身不提供分布式事务，需要集成第三方方案：

**1. TCC 模式（Try-Confirm-Cancel）**

使用 Seata-TCC:
```java
@TwoPhaseBusinessAction(
    name = "createOrder",
    commitMethod = "confirm",
    rollbackMethod = "cancel"
)
public boolean createOrder(Long userId, Order order) {
    // Try: 预留资源
    return orderDao.freeze(order);
}

public boolean confirm(BusinessActionContext context) {
    // Confirm: 确认提交
    return orderDao.commit(context.getOrderId());
}

public boolean cancel(BusinessActionContext context) {
    // Cancel: 取消回滚
    return orderDao.rollback(context.getOrderId());
}
```

**2. SAGA 模式**

使用 Seata-SAGA:
```json
{
  "Name": "createOrderSaga",
  "States": [
    {
      "ServiceName": "orderService",
      "ServiceMethod": "createOrder",
      "CompensateState": "cancelOrder"
    },
    {
      "ServiceName": "paymentService",
      "ServiceMethod": "pay",
      "CompensateState": "refund"
    }
  ]
}
```

**3. AT 模式（自动补偿）**

使用 Seata-AT:
```java
@GlobalTransactional
public void createOrderWithPayment(Order order) {
    orderService.createOrder(order);
    paymentService.pay(order.getAmount());
}
```

**4. 本地消息表**
```java
// 订单服务
@Transactional
public void createOrder(Order order) {
    // 创建订单
    orderDao.insert(order);

    // 保存本地消息
    Message msg = new Message("PaymentService", "pay", order);
    messageDao.insert(msg);
}

// 定时任务发送消息
scheduledTask.sendPendingMessages();
```

**5. MQ 事务消息**
```java
// 使用 RocketMQ 事务消息
TransactionMQProducer producer = new TransactionMQProducer("OrderGroup");

// 发送半消息
producer.sendMessageInTransaction(msg, new LocalTransactionExecuter() {
    @Override
    public LocalTransactionState executeLocalTransaction(Message msg) {
        try {
            orderService.createOrder(order);
            return LocalTransactionState.COMMIT_MESSAGE;
        } catch (Exception e) {
            return LocalTransactionState.ROLLBACK_MESSAGE;
        }
    }
});
```

---

## 高级篇

### 19. Dubbo 的扩展点有哪些？

**答案**:

Dubbo 几乎所有核心功能都是基于 SPI 扩展点实现的：

**1. Protocol 扩展点**
- 协议扩展：dubbo, http, rmi, hessian, webservice 等

**2. Registry 扩展点**
- 注册中心扩展：zookeeper, nacos, redis, multicast 等

**3. LoadBalance 扩展点**
- 负载均衡扩展：random, roundrobin, leastactive, consistenthash 等

**4. Cluster 扩展点**
- 集群容错扩展：failover, failfast, failsafe, failback 等

**5. Router 扩展点**
- 路由扩展：condition, script, tag 等

**6. Filter 扩展点**
- 过滤器扩展：echo, generic, accesslog, timeout 等

**7. Serialization 扩展点**
- 序列化扩展：hessian2, kryo, fst, protobuf, json 等

**8. ProxyFactory 扩展点**
- 代理工厂扩展：javassist, jdk, bytebuddy 等

**9. Transporter 扩展点**
- 网络传输扩展：netty, mina, grizzly 等

**10. Exchanger 扩展点**
- 信息交换扩展：header 等

**自定义扩展示例**:
```java
// 1. 定义扩展点接口
@SPI("myLoadBalance")
public interface LoadBalance {
    <T> Invoker<T> select(List<Invoker<T>> invokers,
                          Invocation invocation);
}

// 2. 实现扩展
public class MyLoadBalance implements LoadBalance {
    @Override
    public <T> Invoker<T> select(List<Invoker<T>> invokers,
                                  Invocation invocation) {
        // 自定义负载均衡逻辑
        return invokers.get(0);
    }
}

// 3. 配置 META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance
myLoadBalance=com.example.MyLoadBalance

// 4. 使用扩展
<dubbo:reference interface="UserService"
                 loadbalance="myLoadBalance" />
```

---

### 20. Dubbo 的核心设计模式有哪些？

**答案**:

**1. 工厂模式 (Factory)**
```java
// ProxyFactory, RegistryFactory, ProtocolFactory
ProxyFactory proxyFactory = ExtensionLoader
    .getExtensionLoader(ProxyFactory.class)
    .getAdaptiveExtension();
```

**2. 单例模式 (Singleton)**
```java
// ExtensionLoader 为每个扩展维护单例
public class ExtensionLoader<T> {
    private static final ConcurrentMap<Class<?>, ExtensionLoader<?>>
        EXTENSION_LOADERS = new ConcurrentHashMap<>();
}
```

**3. 装饰器模式 (Decorator/Wrapper)**
```java
// Wrapper 类自动包装其他扩展实现
public class ProtocolFilterWrapper implements Protocol {
    private final Protocol protocol;

    public ProtocolFilterWrapper(Protocol protocol) {
        this.protocol = protocol;
    }

    @Override
    public <T> Exporter<T> export(Invoker<T> invoker) {
        // 添加 Filter 链
        return protocol.export(buildInvokerChain(invoker));
    }
}
```

**4. 策略模式 (Strategy)**
```java
// LoadBalance, Cluster 都是策略模式
LoadBalance loadBalance = ExtensionLoader
    .getExtensionLoader(LoadBalance.class)
    .getExtension("random");
```

**5. 责任链模式 (Chain of Responsibility)**
```java
// Filter 链
public interface Filter {
    Result invoke(Invoker<?> invoker, Invocation invocation);
}

// Filter1 -> Filter2 -> Filter3 -> ... -> Invoker
```

**6. 观察者模式 (Observer)**
```java
// NotifyListener 监听注册中心变化
public interface NotifyListener {
    void notify(List<URL> urls);
}

registry.subscribe(url, listener);
```

**7. 代理模式 (Proxy)**
```java
// JDK 动态代理、Javassist 代理
UserService proxy = ProxyFactory.getProxy(invoker);
```

**8. 适配器模式 (Adapter)**
```java
// @Adaptive 自适应扩展
@Adaptive({"protocol"})
<T> Exporter<T> export(Invoker<T> invoker);
```

---

## 总结

掌握这些面试题，可以帮助你：

1. **理解 Dubbo 核心概念**: 架构、原理、流程
2. **掌握最佳实践**: 配置、优化、问题排查
3. **应对实际场景**: 性能优化、服务治理、故障处理
4. **深入技术细节**: 设计模式、扩展机制、源码分析

面试时建议：
- 结合实际项目经验回答
- 能画架构图辅助说明
- 了解底层实现原理
- 关注新版本特性

持续学习，不断实践，才能真正掌握 Dubbo！
