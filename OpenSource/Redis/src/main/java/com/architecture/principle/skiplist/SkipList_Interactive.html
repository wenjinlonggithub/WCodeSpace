<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è·³è¡¨å¯è§†åŒ–åŠ¨ç”»æ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            padding: 20px;
        }

        .control-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            height: fit-content;
        }

        .control-section {
            margin-bottom: 25px;
        }

        .control-section h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }

        .control-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .control-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .btn-warning {
            background: #ffc107;
            color: black;
        }

        .btn-warning:hover {
            background: #e0a800;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-info:hover {
            background: #138496;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(23, 162, 184, 0.4);
        }

        .visualization-area {
            background: white;
            border-radius: 10px;
            padding: 20px;
        }

        #canvas-container {
            background: #ffffff;
            border: 2px solid #ddd;
            border-radius: 10px;
            overflow-x: auto;
            overflow-y: hidden;
            position: relative;
            min-height: 500px;
        }

        #skiplist-canvas {
            display: block;
            cursor: pointer;
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        #step-info {
            background: white;
            padding: 15px;
            border-radius: 5px;
            min-height: 80px;
            border-left: 4px solid #667eea;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .stat-card .label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 5px;
        }

        .stat-card .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #667eea;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-control input[type="range"] {
            flex: 1;
        }

        .legend {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #333;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }

        .tab {
            padding: 12px 24px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s;
            color: #666;
        }

        .tab.active {
            background: #667eea;
            color: white;
        }

        .tab:hover:not(.active) {
            background: #e9ecef;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .example-btn {
            margin: 5px 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .pulsing {
            animation: pulse 1s infinite;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .slide-in {
            animation: slideIn 0.5s ease-out;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ è·³è¡¨å¯è§†åŒ–åŠ¨ç”»æ¼”ç¤º</h1>
            <p>äº¤äº’å¼å­¦ä¹ è·³è¡¨æ•°æ®ç»“æ„ - å®æ—¶åŠ¨ç”»å±•ç¤ºæ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾ç­‰æ“ä½œ</p>
        </div>

        <div class="main-content">
            <!-- å·¦ä¾§æ§åˆ¶é¢æ¿ -->
            <div class="control-panel">
                <!-- æ“ä½œé€‰æ‹© -->
                <div class="control-section">
                    <h3>ğŸ® æ“ä½œæ§åˆ¶</h3>
                    <div class="control-group">
                        <label>èŠ‚ç‚¹å€¼:</label>
                        <input type="text" id="nodeValue" placeholder="ä¾‹å¦‚: user1">
                    </div>
                    <div class="control-group">
                        <label>åˆ†æ•°:</label>
                        <input type="number" id="nodeScore" placeholder="ä¾‹å¦‚: 100" step="10">
                    </div>
                    <button class="btn btn-primary" onclick="insertNode()">â• æ’å…¥èŠ‚ç‚¹</button>
                    <button class="btn btn-danger" onclick="deleteNode()">â– åˆ é™¤èŠ‚ç‚¹</button>
                    <button class="btn btn-success" onclick="searchNode()">ğŸ” æŸ¥æ‰¾èŠ‚ç‚¹</button>
                    <button class="btn btn-info" onclick="rangeQuery()">ğŸ“Š èŒƒå›´æŸ¥è¯¢</button>
                </div>

                <!-- å¿«é€Ÿç¤ºä¾‹ -->
                <div class="control-section">
                    <h3>âš¡ å¿«é€Ÿç¤ºä¾‹</h3>
                    <button class="btn btn-warning example-btn" onclick="demoInsert()">æ¼”ç¤ºæ’å…¥</button>
                    <button class="btn btn-warning example-btn" onclick="demoDelete()">æ¼”ç¤ºåˆ é™¤</button>
                    <button class="btn btn-warning example-btn" onclick="demoSearch()">æ¼”ç¤ºæŸ¥æ‰¾</button>
                    <button class="btn btn-warning example-btn" onclick="demoRange()">æ¼”ç¤ºèŒƒå›´æŸ¥è¯¢</button>
                    <button class="btn btn-danger" onclick="clearSkipList()">ğŸ—‘ï¸ æ¸…ç©ºè·³è¡¨</button>
                </div>

                <!-- åŠ¨ç”»æ§åˆ¶ -->
                <div class="control-section">
                    <h3>âš™ï¸ åŠ¨ç”»è®¾ç½®</h3>
                    <div class="speed-control">
                        <label>é€Ÿåº¦:</label>
                        <input type="range" id="speed" min="1" max="10" value="5">
                        <span id="speedValue">5</span>
                    </div>
                    <button class="btn btn-primary" id="playPauseBtn" onclick="togglePlayPause()" style="margin-top: 10px;">
                        â¸ï¸ æš‚åœ
                    </button>
                    <button class="btn btn-info" onclick="stepForward()">â­ï¸ ä¸‹ä¸€æ­¥</button>
                    <button class="btn btn-info" onclick="resetAnimation()">ğŸ”„ é‡ç½®</button>
                </div>

                <!-- å›¾ä¾‹ -->
                <div class="control-section">
                    <h3>ğŸ“– å›¾ä¾‹è¯´æ˜</h3>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #90EE90;"></div>
                            <span>æ­£å¸¸èŠ‚ç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FFD700;"></div>
                            <span>å½“å‰èŠ‚ç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #FF6B6B;"></div>
                            <span>ç›®æ ‡èŠ‚ç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #87CEEB;"></div>
                            <span>è®¿é—®è¿‡çš„</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§å¯è§†åŒ–åŒºåŸŸ -->
            <div class="visualization-area">
                <!-- æ ‡ç­¾é¡µ -->
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('visualization')">ğŸ¨ å¯è§†åŒ–åŠ¨ç”»</button>
                    <button class="tab" onclick="switchTab('flowchart')">ğŸ“Š æµç¨‹å›¾</button>
                    <button class="tab" onclick="switchTab('code')">ğŸ’» ä»£ç å®ç°</button>
                </div>

                <!-- å¯è§†åŒ–æ ‡ç­¾é¡µ -->
                <div id="visualization" class="tab-content active">
                    <div id="canvas-container">
                        <canvas id="skiplist-canvas"></canvas>
                    </div>

                    <!-- æ­¥éª¤è¯´æ˜ -->
                    <div class="info-panel">
                        <h3>ğŸ“ æ“ä½œæ­¥éª¤</h3>
                        <div id="step-info">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¼€å§‹æ“ä½œï¼Œæˆ–é€‰æ‹©å¿«é€Ÿç¤ºä¾‹æŸ¥çœ‹åŠ¨ç”»æ¼”ç¤º</div>
                    </div>

                    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
                    <div class="stats">
                        <div class="stat-card">
                            <div class="label">èŠ‚ç‚¹æ€»æ•°</div>
                            <div class="value" id="nodeCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æœ€å¤§å±‚æ•°</div>
                            <div class="value" id="maxLevel">1</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æ“ä½œæ¬¡æ•°</div>
                            <div class="value" id="operationCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">å½“å‰æ­¥éª¤</div>
                            <div class="value" id="currentStep">0/0</div>
                        </div>
                    </div>
                </div>

                <!-- æµç¨‹å›¾æ ‡ç­¾é¡µ -->
                <div id="flowchart" class="tab-content">
                    <iframe src="SkipList_FlowChart.html" style="width: 100%; height: 800px; border: none; border-radius: 10px;"></iframe>
                </div>

                <!-- ä»£ç å®ç°æ ‡ç­¾é¡µ -->
                <div id="code" class="tab-content">
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 10px;">
                        <h3 style="color: #667eea; margin-bottom: 15px;">è·³è¡¨æ ¸å¿ƒå®ç°ä»£ç </h3>
                        <pre style="background: #282c34; color: #abb2bf; padding: 20px; border-radius: 8px; overflow-x: auto; line-height: 1.6;"><code>class SkipListNode {
    constructor(value, score, level) {
        this.value = value;
        this.score = score;
        this.forward = new Array(level).fill(null);
    }
}

class SkipList {
    constructor() {
        this.maxLevel = 16;
        this.probability = 0.25;
        this.level = 1;
        this.head = new SkipListNode(null, -Infinity, this.maxLevel);
    }

    // éšæœºç”Ÿæˆå±‚æ•°
    randomLevel() {
        let level = 1;
        while (Math.random() < this.probability && level < this.maxLevel) {
            level++;
        }
        return level;
    }

    // æ’å…¥èŠ‚ç‚¹
    insert(value, score) {
        const update = new Array(this.maxLevel).fill(null);
        let current = this.head;

        // ä»æœ€é«˜å±‚å¼€å§‹æŸ¥æ‰¾æ’å…¥ä½ç½®
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].score < score) {
                current = current.forward[i];
            }
            update[i] = current;
        }

        // éšæœºç”Ÿæˆæ–°èŠ‚ç‚¹çš„å±‚æ•°
        const newLevel = this.randomLevel();
        if (newLevel > this.level) {
            for (let i = this.level; i < newLevel; i++) {
                update[i] = this.head;
            }
            this.level = newLevel;
        }

        // åˆ›å»ºæ–°èŠ‚ç‚¹å¹¶æ’å…¥
        const newNode = new SkipListNode(value, score, newLevel);
        for (let i = 0; i < newLevel; i++) {
            newNode.forward[i] = update[i].forward[i];
            update[i].forward[i] = newNode;
        }
    }

    // æŸ¥æ‰¾èŠ‚ç‚¹
    search(score) {
        let current = this.head;
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].score < score) {
                current = current.forward[i];
            }
        }
        current = current.forward[0];
        return current && current.score === score ? current : null;
    }

    // åˆ é™¤èŠ‚ç‚¹
    delete(value, score) {
        const update = new Array(this.maxLevel).fill(null);
        let current = this.head;

        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].score < score) {
                current = current.forward[i];
            }
            update[i] = current;
        }

        current = current.forward[0];
        if (current && current.score === score && current.value === value) {
            for (let i = 0; i < this.level; i++) {
                if (update[i].forward[i] !== current) break;
                update[i].forward[i] = current.forward[i];
            }

            while (this.level > 1 && !this.head.forward[this.level - 1]) {
                this.level--;
            }
            return true;
        }
        return false;
    }

    // èŒƒå›´æŸ¥è¯¢
    rangeByScore(minScore, maxScore) {
        const result = [];
        let current = this.head;

        // å¿«é€Ÿå®šä½åˆ°èµ·å§‹ä½ç½®
        for (let i = this.level - 1; i >= 0; i--) {
            while (current.forward[i] && current.forward[i].score < minScore) {
                current = current.forward[i];
            }
        }

        // æ”¶é›†èŒƒå›´å†…çš„èŠ‚ç‚¹
        current = current.forward[0];
        while (current && current.score <= maxScore) {
            result.push(current);
            current = current.forward[0];
        }

        return result;
    }
}</code></pre>
                        <div style="margin-top: 20px; padding: 15px; background: #e7f3ff; border-radius: 8px; border-left: 4px solid #2196F3;">
                            <h4 style="color: #2196F3; margin-bottom: 10px;">ğŸ’¡ ä»£ç è¯´æ˜</h4>
                            <ul style="line-height: 1.8; color: #333;">
                                <li><strong>æ—¶é—´å¤æ‚åº¦ï¼š</strong>æ’å…¥ã€åˆ é™¤ã€æŸ¥æ‰¾éƒ½æ˜¯ O(logN)</li>
                                <li><strong>ç©ºé—´å¤æ‚åº¦ï¼š</strong>O(N)ï¼ŒæœŸæœ›æ¯ä¸ªèŠ‚ç‚¹ 1.33 ä¸ªæŒ‡é’ˆ</li>
                                <li><strong>æ¦‚ç‡å› å­ï¼š</strong>P=0.25ï¼Œå¹³è¡¡ç©ºé—´å’Œæ—¶é—´</li>
                                <li><strong>æœ€å¤§å±‚æ•°ï¼š</strong>16å±‚ï¼Œæ”¯æŒçº¦ 65536 ä¸ªèŠ‚ç‚¹</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==================== è·³è¡¨æ•°æ®ç»“æ„å®ç° ====================
        class SkipListNode {
            constructor(value, score, level) {
                this.value = value;
                this.score = score;
                this.forward = new Array(level).fill(null);
                this.x = 0;
                this.y = 0;
            }
        }

        class SkipList {
            constructor() {
                this.maxLevel = 16;
                this.probability = 0.25;
                this.level = 1;
                this.head = new SkipListNode('HEAD', -Infinity, this.maxLevel);
                this.nodeCount = 0;
            }

            randomLevel() {
                let level = 1;
                while (Math.random() < this.probability && level < this.maxLevel) {
                    level++;
                }
                return level;
            }

            insert(value, score) {
                const steps = [];
                const update = new Array(this.maxLevel).fill(null);
                let current = this.head;

                steps.push({
                    type: 'init',
                    message: `å¼€å§‹æ’å…¥èŠ‚ç‚¹ ${value}(${score})ï¼Œä»æœ€é«˜å±‚ Level ${this.level - 1} å¼€å§‹æŸ¥æ‰¾æ’å…¥ä½ç½®`
                });

                for (let i = this.level - 1; i >= 0; i--) {
                    steps.push({
                        type: 'search',
                        level: i,
                        current: current,
                        message: `åœ¨ Level ${i} å±‚æŸ¥æ‰¾æ’å…¥ä½ç½®`
                    });

                    while (current.forward[i] && current.forward[i].score < score) {
                        current = current.forward[i];
                        steps.push({
                            type: 'move',
                            level: i,
                            current: current,
                            message: `ç§»åŠ¨åˆ°èŠ‚ç‚¹ ${current.value}(${current.score})`
                        });
                    }
                    update[i] = current;
                }

                const newLevel = this.randomLevel();
                steps.push({
                    type: 'random_level',
                    level: newLevel,
                    message: `éšæœºç”Ÿæˆå±‚æ•°: ${newLevel}`
                });

                if (newLevel > this.level) {
                    for (let i = this.level; i < newLevel; i++) {
                        update[i] = this.head;
                    }
                    this.level = newLevel;
                }

                const newNode = new SkipListNode(value, score, newLevel);
                for (let i = 0; i < newLevel; i++) {
                    newNode.forward[i] = update[i].forward[i];
                    update[i].forward[i] = newNode;
                }

                steps.push({
                    type: 'insert_complete',
                    node: newNode,
                    message: `æˆåŠŸæ’å…¥èŠ‚ç‚¹ ${value}(${score})ï¼Œå±‚æ•°: ${newLevel}`
                });

                this.nodeCount++;
                return steps;
            }

            search(score) {
                const steps = [];
                let current = this.head;

                steps.push({
                    type: 'init',
                    message: `å¼€å§‹æŸ¥æ‰¾åˆ†æ•°ä¸º ${score} çš„èŠ‚ç‚¹`
                });

                for (let i = this.level - 1; i >= 0; i--) {
                    steps.push({
                        type: 'search',
                        level: i,
                        current: current,
                        message: `åœ¨ Level ${i} å±‚æŸ¥æ‰¾`
                    });

                    while (current.forward[i] && current.forward[i].score < score) {
                        current = current.forward[i];
                        steps.push({
                            type: 'move',
                            level: i,
                            current: current,
                            message: `ç§»åŠ¨åˆ°èŠ‚ç‚¹ ${current.value}(${current.score})`
                        });
                    }
                }

                current = current.forward[0];
                if (current && current.score === score) {
                    steps.push({
                        type: 'found',
                        node: current,
                        message: `âœ… æ‰¾åˆ°èŠ‚ç‚¹ ${current.value}(${current.score})`
                    });
                    return { found: true, steps, node: current };
                } else {
                    steps.push({
                        type: 'not_found',
                        message: `âŒ æœªæ‰¾åˆ°åˆ†æ•°ä¸º ${score} çš„èŠ‚ç‚¹`
                    });
                    return { found: false, steps };
                }
            }

            delete(value, score) {
                const steps = [];
                const update = new Array(this.maxLevel).fill(null);
                let current = this.head;

                steps.push({
                    type: 'init',
                    message: `å¼€å§‹åˆ é™¤èŠ‚ç‚¹ ${value}(${score})`
                });

                for (let i = this.level - 1; i >= 0; i--) {
                    while (current.forward[i] && current.forward[i].score < score) {
                        current = current.forward[i];
                    }
                    update[i] = current;
                }

                current = current.forward[0];
                if (current && current.score === score && current.value === value) {
                    for (let i = 0; i < this.level; i++) {
                        if (update[i].forward[i] !== current) break;
                        update[i].forward[i] = current.forward[i];
                        steps.push({
                            type: 'delete_level',
                            level: i,
                            message: `åˆ é™¤ Level ${i} å±‚çš„è¿æ¥`
                        });
                    }

                    while (this.level > 1 && !this.head.forward[this.level - 1]) {
                        this.level--;
                    }

                    steps.push({
                        type: 'delete_complete',
                        message: `âœ… æˆåŠŸåˆ é™¤èŠ‚ç‚¹ ${value}(${score})`
                    });

                    this.nodeCount--;
                    return { success: true, steps };
                } else {
                    steps.push({
                        type: 'not_found',
                        message: `âŒ æœªæ‰¾åˆ°èŠ‚ç‚¹ ${value}(${score})`
                    });
                    return { success: false, steps };
                }
            }

            rangeByScore(minScore, maxScore) {
                const steps = [];
                const result = [];
                let current = this.head;

                steps.push({
                    type: 'init',
                    message: `å¼€å§‹èŒƒå›´æŸ¥è¯¢ [${minScore}, ${maxScore}]`
                });

                for (let i = this.level - 1; i >= 0; i--) {
                    while (current.forward[i] && current.forward[i].score < minScore) {
                        current = current.forward[i];
                    }
                }

                current = current.forward[0];
                while (current && current.score <= maxScore) {
                    result.push(current);
                    steps.push({
                        type: 'collect',
                        node: current,
                        message: `æ”¶é›†èŠ‚ç‚¹ ${current.value}(${current.score})`
                    });
                    current = current.forward[0];
                }

                steps.push({
                    type: 'complete',
                    count: result.length,
                    message: `âœ… æ‰¾åˆ° ${result.length} ä¸ªèŠ‚ç‚¹`
                });

                return { result, steps };
            }

            getAllNodes() {
                const nodes = [];
                let current = this.head.forward[0];
                while (current) {
                    nodes.push(current);
                    current = current.forward[0];
                }
                return nodes;
            }

            clear() {
                this.level = 1;
                this.head = new SkipListNode('HEAD', -Infinity, this.maxLevel);
                this.nodeCount = 0;
            }
        }

        // ==================== å¯è§†åŒ–å¼•æ“ ====================
        class SkipListVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.skipList = new SkipList();
                this.animationSteps = [];
                this.currentStepIndex = 0;
                this.isPlaying = false;
                this.animationSpeed = 1000;
                this.operationCount = 0;

                this.nodeWidth = 80;
                this.nodeHeight = 40;
                this.levelHeight = 60;
                this.startX = 50;
                this.startY = 50;

                this.colors = {
                    normal: '#90EE90',
                    current: '#FFD700',
                    target: '#FF6B6B',
                    visited: '#87CEEB',
                    head: '#DDA0DD'
                };

                this.resizeCanvas();
                this.draw();

                // ç›‘å¬é€Ÿåº¦æ»‘å—
                document.getElementById('speed').addEventListener('input', (e) => {
                    const speed = parseInt(e.target.value);
                    document.getElementById('speedValue').textContent = speed;
                    this.animationSpeed = 2000 / speed;
                });
            }

            resizeCanvas() {
                const container = document.getElementById('canvas-container');
                const nodes = this.skipList.getAllNodes();
                const minWidth = container.clientWidth - 4;
                const requiredWidth = this.startX + (nodes.length + 1) * (this.nodeWidth + 30) + 50;

                this.canvas.width = Math.max(minWidth, requiredWidth);
                this.canvas.height = this.skipList.level * this.levelHeight + 100;
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.resizeCanvas();

                // ç»˜åˆ¶å±‚çº§æ ‡ç­¾
                for (let i = this.skipList.level - 1; i >= 0; i--) {
                    const y = this.startY + (this.skipList.level - 1 - i) * this.levelHeight;
                    this.ctx.fillStyle = '#666';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.fillText(`L${i}`, 10, y + 20);
                }

                // è®¡ç®—æ‰€æœ‰èŠ‚ç‚¹çš„ä½ç½®
                const nodes = [this.skipList.head, ...this.skipList.getAllNodes()];
                let xPos = this.startX;
                nodes.forEach(node => {
                    node.x = xPos;
                    xPos += this.nodeWidth + 30;
                });

                // ç»˜åˆ¶æ‰€æœ‰å±‚çš„è¿æ¥çº¿
                for (let level = this.skipList.level - 1; level >= 0; level--) {
                    let current = this.skipList.head;
                    const y = this.startY + (this.skipList.level - 1 - level) * this.levelHeight;

                    while (current) {
                        if (current.forward[level]) {
                            const nextNode = current.forward[level];
                            this.drawArrow(
                                current.x + this.nodeWidth,
                                y + this.nodeHeight / 2,
                                nextNode.x,
                                y + this.nodeHeight / 2,
                                '#999'
                            );
                        }
                        current = current.forward[level];
                    }
                }

                // ç»˜åˆ¶æ‰€æœ‰èŠ‚ç‚¹
                nodes.forEach(node => {
                    for (let i = 0; i < node.forward.length && i < this.skipList.level; i++) {
                        const y = this.startY + (this.skipList.level - 1 - i) * this.levelHeight;
                        const color = node === this.skipList.head ? this.colors.head : this.colors.normal;
                        this.drawNode(node, node.x, y, color);
                    }
                });

                this.updateStats();
            }

            drawNode(node, x, y, color) {
                // ç»˜åˆ¶çŸ©å½¢
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, this.nodeWidth, this.nodeHeight);
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(x, y, this.nodeWidth, this.nodeHeight);

                // ç»˜åˆ¶æ–‡æœ¬
                this.ctx.fillStyle = '#000';
                this.ctx.font = 'bold 12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';

                if (node === this.skipList.head) {
                    this.ctx.fillText('HEAD', x + this.nodeWidth / 2, y + this.nodeHeight / 2);
                } else {
                    this.ctx.fillText(node.value, x + this.nodeWidth / 2, y + this.nodeHeight / 2 - 8);
                    this.ctx.font = '10px Arial';
                    this.ctx.fillText(`(${node.score})`, x + this.nodeWidth / 2, y + this.nodeHeight / 2 + 8);
                }
            }

            drawArrow(fromX, fromY, toX, toY, color) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(fromX, fromY);
                this.ctx.lineTo(toX, toY);
                this.ctx.stroke();

                // ç®­å¤´
                const angle = Math.atan2(toY - fromY, toX - fromX);
                const arrowSize = 8;
                this.ctx.beginPath();
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(
                    toX - arrowSize * Math.cos(angle - Math.PI / 6),
                    toY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                this.ctx.moveTo(toX, toY);
                this.ctx.lineTo(
                    toX - arrowSize * Math.cos(angle + Math.PI / 6),
                    toY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                this.ctx.stroke();
            }

            highlightNode(node, level, color) {
                if (!node || node === this.skipList.head) return;
                const y = this.startY + (this.skipList.level - 1 - level) * this.levelHeight;
                this.drawNode(node, node.x, y, color);
            }

            async playAnimation(steps) {
                this.animationSteps = steps;
                this.currentStepIndex = 0;
                this.isPlaying = true;
                this.updatePlayPauseButton();

                for (let i = 0; i < steps.length && this.isPlaying; i++) {
                    this.currentStepIndex = i;
                    await this.executeStep(steps[i]);
                    this.updateStepInfo(steps[i]);
                    document.getElementById('currentStep').textContent = `${i + 1}/${steps.length}`;
                    await this.sleep(this.animationSpeed);
                }

                this.isPlaying = false;
                this.updatePlayPauseButton();
                this.draw();
            }

            async executeStep(step) {
                this.draw();

                switch (step.type) {
                    case 'search':
                    case 'move':
                        if (step.current && step.level !== undefined) {
                            this.highlightNode(step.current, step.level, this.colors.current);
                        }
                        break;
                    case 'found':
                    case 'insert_complete':
                        if (step.node) {
                            for (let i = 0; i < step.node.forward.length; i++) {
                                this.highlightNode(step.node, i, this.colors.target);
                            }
                        }
                        break;
                    case 'collect':
                        if (step.node) {
                            this.highlightNode(step.node, 0, this.colors.visited);
                        }
                        break;
                }
            }

            updateStepInfo(step) {
                const stepInfo = document.getElementById('step-info');
                stepInfo.textContent = step.message || 'æ‰§è¡Œä¸­...';
                stepInfo.className = 'slide-in';
                setTimeout(() => stepInfo.className = '', 500);
            }

            updateStats() {
                document.getElementById('nodeCount').textContent = this.skipList.nodeCount;
                document.getElementById('maxLevel').textContent = this.skipList.level;
                document.getElementById('operationCount').textContent = this.operationCount;
            }

            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            pause() {
                this.isPlaying = false;
                this.updatePlayPauseButton();
            }

            resume() {
                if (this.animationSteps.length > 0 && this.currentStepIndex < this.animationSteps.length) {
                    this.isPlaying = true;
                    this.updatePlayPauseButton();
                    this.continueAnimation();
                }
            }

            async continueAnimation() {
                for (let i = this.currentStepIndex; i < this.animationSteps.length && this.isPlaying; i++) {
                    this.currentStepIndex = i;
                    await this.executeStep(this.animationSteps[i]);
                    this.updateStepInfo(this.animationSteps[i]);
                    document.getElementById('currentStep').textContent = `${i + 1}/${this.animationSteps.length}`;
                    await this.sleep(this.animationSpeed);
                }
                this.isPlaying = false;
                this.updatePlayPauseButton();
                this.draw();
            }

            stepForward() {
                if (this.animationSteps.length > 0 && this.currentStepIndex < this.animationSteps.length - 1) {
                    this.currentStepIndex++;
                    this.executeStep(this.animationSteps[this.currentStepIndex]);
                    this.updateStepInfo(this.animationSteps[this.currentStepIndex]);
                    document.getElementById('currentStep').textContent =
                        `${this.currentStepIndex + 1}/${this.animationSteps.length}`;
                }
            }

            reset() {
                this.pause();
                this.currentStepIndex = 0;
                document.getElementById('currentStep').textContent = '0/0';
                document.getElementById('step-info').textContent = 'å·²é‡ç½®';
                this.draw();
            }

            updatePlayPauseButton() {
                const btn = document.getElementById('playPauseBtn');
                btn.textContent = this.isPlaying ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ ç»§ç»­';
            }
        }

        // ==================== å…¨å±€å®ä¾‹å’Œæ§åˆ¶å‡½æ•° ====================
        let visualizer;

        window.onload = function() {
            visualizer = new SkipListVisualizer('skiplist-canvas');
            // åˆå§‹åŒ–ä¸€äº›ç¤ºä¾‹æ•°æ®
            const initData = [
                { value: 'A', score: 10 },
                { value: 'B', score: 30 },
                { value: 'C', score: 50 },
                { value: 'D', score: 70 }
            ];

            initData.forEach(data => {
                visualizer.skipList.insert(data.value, data.score);
            });
            visualizer.draw();
        };

        // æ’å…¥èŠ‚ç‚¹
        async function insertNode() {
            const value = document.getElementById('nodeValue').value;
            const score = parseFloat(document.getElementById('nodeScore').value);

            if (!value || isNaN(score)) {
                alert('è¯·è¾“å…¥èŠ‚ç‚¹å€¼å’Œåˆ†æ•°ï¼');
                return;
            }

            visualizer.operationCount++;
            const steps = visualizer.skipList.insert(value, score);
            await visualizer.playAnimation(steps);
        }

        // åˆ é™¤èŠ‚ç‚¹
        async function deleteNode() {
            const value = document.getElementById('nodeValue').value;
            const score = parseFloat(document.getElementById('nodeScore').value);

            if (!value || isNaN(score)) {
                alert('è¯·è¾“å…¥è¦åˆ é™¤çš„èŠ‚ç‚¹å€¼å’Œåˆ†æ•°ï¼');
                return;
            }

            visualizer.operationCount++;
            const result = visualizer.skipList.delete(value, score);
            await visualizer.playAnimation(result.steps);
        }

        // æŸ¥æ‰¾èŠ‚ç‚¹
        async function searchNode() {
            const score = parseFloat(document.getElementById('nodeScore').value);

            if (isNaN(score)) {
                alert('è¯·è¾“å…¥è¦æŸ¥æ‰¾çš„åˆ†æ•°ï¼');
                return;
            }

            visualizer.operationCount++;
            const result = visualizer.skipList.search(score);
            await visualizer.playAnimation(result.steps);
        }

        // èŒƒå›´æŸ¥è¯¢
        async function rangeQuery() {
            const minScore = parseFloat(prompt('è¯·è¾“å…¥æœ€å°åˆ†æ•°:', '20'));
            const maxScore = parseFloat(prompt('è¯·è¾“å…¥æœ€å¤§åˆ†æ•°:', '60'));

            if (isNaN(minScore) || isNaN(maxScore)) {
                return;
            }

            visualizer.operationCount++;
            const result = visualizer.skipList.rangeByScore(minScore, maxScore);
            await visualizer.playAnimation(result.steps);
        }

        // æ¼”ç¤ºæ’å…¥
        async function demoInsert() {
            const demos = [
                { value: 'P1', score: 25 },
                { value: 'P2', score: 45 },
                { value: 'P3', score: 65 }
            ];

            for (const demo of demos) {
                document.getElementById('nodeValue').value = demo.value;
                document.getElementById('nodeScore').value = demo.score;
                await insertNode();
                await visualizer.sleep(500);
            }
        }

        // æ¼”ç¤ºåˆ é™¤
        async function demoDelete() {
            const nodes = visualizer.skipList.getAllNodes();
            if (nodes.length === 0) {
                alert('è·³è¡¨ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ èŠ‚ç‚¹ï¼');
                return;
            }

            const node = nodes[Math.floor(nodes.length / 2)];
            document.getElementById('nodeValue').value = node.value;
            document.getElementById('nodeScore').value = node.score;
            await deleteNode();
        }

        // æ¼”ç¤ºæŸ¥æ‰¾
        async function demoSearch() {
            const nodes = visualizer.skipList.getAllNodes();
            if (nodes.length === 0) {
                alert('è·³è¡¨ä¸ºç©ºï¼Œè¯·å…ˆæ·»åŠ èŠ‚ç‚¹ï¼');
                return;
            }

            const node = nodes[Math.floor(Math.random() * nodes.length)];
            document.getElementById('nodeScore').value = node.score;
            await searchNode();
        }

        // æ¼”ç¤ºèŒƒå›´æŸ¥è¯¢
        async function demoRange() {
            const nodes = visualizer.skipList.getAllNodes();
            if (nodes.length < 2) {
                alert('èŠ‚ç‚¹æ•°é‡ä¸è¶³ï¼Œè¯·å…ˆæ·»åŠ æ›´å¤šèŠ‚ç‚¹ï¼');
                return;
            }

            const minIdx = Math.floor(nodes.length * 0.25);
            const maxIdx = Math.floor(nodes.length * 0.75);

            visualizer.operationCount++;
            const result = visualizer.skipList.rangeByScore(
                nodes[minIdx].score,
                nodes[maxIdx].score
            );
            await visualizer.playAnimation(result.steps);
        }

        // æ¸…ç©ºè·³è¡¨
        function clearSkipList() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºè·³è¡¨å—ï¼Ÿ')) {
                visualizer.skipList.clear();
                visualizer.animationSteps = [];
                visualizer.currentStepIndex = 0;
                visualizer.operationCount = 0;
                visualizer.draw();
                document.getElementById('step-info').textContent = 'è·³è¡¨å·²æ¸…ç©º';
            }
        }

        // æ’­æ”¾/æš‚åœæ§åˆ¶
        function togglePlayPause() {
            if (visualizer.isPlaying) {
                visualizer.pause();
            } else {
                visualizer.resume();
            }
        }

        // ä¸‹ä¸€æ­¥
        function stepForward() {
            visualizer.stepForward();
        }

        // é‡ç½®åŠ¨ç”»
        function resetAnimation() {
            visualizer.reset();
        }

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabName) {
            // ç§»é™¤æ‰€æœ‰æ´»åŠ¨çŠ¶æ€
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

            // æ¿€æ´»é€‰ä¸­çš„æ ‡ç­¾
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
        }
    </script>
</body>
</html>
