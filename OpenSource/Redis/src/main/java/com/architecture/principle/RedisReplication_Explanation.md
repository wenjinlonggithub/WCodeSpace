# Redis 主从复制原理详解 🔄

## 目录
1. [什么是主从复制](#什么是主从复制)
2. [核心概念](#核心概念)
3. [全量复制流程](#全量复制流程)
4. [增量复制流程](#增量复制流程)
5. [命令传播](#命令传播)
6. [复制积压缓冲区](#复制积压缓冲区)
7. [心跳检测](#心跳检测)
8. [实际应用场景](#实际应用场景)

---

## 什么是主从复制

### 大白话解释

**主从复制就像：老师（主节点）讲课，学生（从节点）记笔记。**

- 老师说什么，学生就记什么
- 学生迟到了，老师会把之前的内容重新讲一遍（全量复制）
- 学生上厕所回来，老师只需要讲错过的部分（增量复制）

### 正式定义

主从复制（Replication）是Redis实现高可用的基础机制：
- **主节点（Master）**：接收写操作，负责数据的修改
- **从节点（Slave/Replica）**：复制主节点的数据，提供读操作

### 作用

1. **数据备份**：从节点是主节点的副本
2. **读写分离**：主节点写，从节点读，提高并发能力
3. **故障恢复**：主节点挂了，从节点可以升级为主节点
4. **高可用基础**：Redis Sentinel 和 Redis Cluster 都基于主从复制

---

## 核心概念

### 1. Replication ID（复制ID）

**作用：** 唯一标识一个数据集

```
场景：
主节点A: replication_id = "abc123"
主节点B: replication_id = "def456"

从节点连接时，通过对比ID判断是否连接的是原来的主节点
```

**什么时候会改变？**
- Redis重启
- 从节点晋升为主节点
- 手动执行 REPLICAOF NO ONE

### 2. Replication Offset（复制偏移量）

**作用：** 记录已复制的数据量（字节数）

```
主节点执行了3个命令：
SET name "Redis"      → offset = 0 + 15 = 15
SET version "7.0"     → offset = 15 + 14 = 29
SET type "database"   → offset = 29 + 17 = 46

主节点 offset: 46
从节点 offset: 46  ✅ 数据同步
从节点 offset: 29  ⚠️ 落后17字节
```

**用途：**
- 判断主从数据是否一致
- 增量复制时，确定从哪里开始复制

### 3. Replication Backlog（复制积压缓冲区）

**作用：** 保存最近的写命令，用于增量复制

```
这是一个环形缓冲区，默认1MB：

┌─────────────────────────────────────┐
│ SET k1 v1 | SET k2 v2 | SET k3 v3  │ ← 新命令追加到这里
└─────────────────────────────────────┘
  ↑                                 ↑
minOffset                      maxOffset
(最旧的命令)                    (最新的命令)

如果缓冲区满了，最旧的命令会被覆盖
```

**配置：**
```bash
repl-backlog-size 1mb     # 缓冲区大小
repl-backlog-ttl 3600     # 没有从节点时，保持缓冲区的时间
```

---

## 全量复制流程

### 流程图

```
从节点                                  主节点
  │                                      │
  │  1. PSYNC ? -1                      │
  ├──────────────────────────────────>  │
  │                                      │
  │  2. +FULLRESYNC <replid> <offset>   │
  │  <──────────────────────────────────┤
  │                                      │
  │                                      │ 3. BGSAVE
  │                                      │    生成RDB文件
  │                                      │
  │  4. 发送RDB文件                     │
  │  <──────────────────────────────────┤
  │                                      │
  │  5. 清空旧数据，加载RDB             │
  │                                      │
  │  6. 发送缓冲区命令                  │
  │  <──────────────────────────────────┤
  │                                      │
  │  7. 持续接收命令                    │
  │  <══════════════════════════════════┤
  │                                      │
```

### 详细步骤

#### 步骤1：从节点发送PSYNC命令

```bash
# 第一次连接，不知道主节点的信息
PSYNC ? -1

参数说明：
? : 表示不知道主节点的 replication_id
-1: 表示从头开始复制
```

#### 步骤2：主节点响应FULLRESYNC

```bash
+FULLRESYNC abc123def456... 0

参数说明：
abc123def456...: 主节点的 replication_id
0: 当前的复制偏移量
```

#### 步骤3：主节点执行BGSAVE

```
主节点执行：
1. fork 一个子进程
2. 子进程生成 RDB 快照文件
3. 父进程继续处理客户端请求
4. 父进程将新的写命令缓存到缓冲区
```

**为什么用BGSAVE而不是SAVE？**
- SAVE：阻塞主进程，期间无法处理请求 ❌
- BGSAVE：非阻塞，不影响服务 ✅

#### 步骤4：发送RDB文件

```
主节点 → 从节点

1. 发送 RDB 文件头（魔数、版本）
2. 发送数据库数据
3. 发送 EOF 标记
4. 发送校验和
```

#### 步骤5：从节点加载RDB

```
从节点：
1. 清空旧数据（如果有）
2. 加载 RDB 文件
3. 更新 replication_id 和 offset
```

#### 步骤6：发送缓冲区命令

```
在生成和传输RDB期间，主节点接收到的写命令会被缓存

现在这些命令都发送给从节点：
SET new_key1 value1
SET new_key2 value2
DEL old_key
...
```

#### 步骤7：进入命令传播阶段

全量复制完成，进入正常的命令传播模式。

---

## 增量复制流程

### 什么时候用增量复制？

**场景：** 从节点短暂断线后重连

```
时间线：
10:00 - 从节点正常工作，offset = 1000
10:05 - 从节点网络断开
10:06 - 主节点执行了一些命令，offset = 1200
10:07 - 从节点重连，offset = 1000

问题：从节点落后了200字节
解决：增量复制，只传输这200字节的命令
```

### 流程图

```
从节点                                  主节点
  │                                      │
  │  1. PSYNC <replid> <offset>         │
  ├──────────────────────────────────>  │
  │                                      │
  │                                      │ 2. 检查backlog
  │                                      │    判断是否可以增量复制
  │                                      │
  │  3. +CONTINUE                        │
  │  <──────────────────────────────────┤
  │                                      │
  │  4. 发送增量命令                    │
  │     (offset 1000 → 1200)            │
  │  <──────────────────────────────────┤
  │                                      │
  │  5. 执行命令，更新offset            │
  │                                      │
  │  6. 继续命令传播                    │
  │  <══════════════════════════════════┤
  │                                      │
```

### 详细步骤

#### 步骤1：从节点发送PSYNC命令

```bash
PSYNC abc123def456... 1000

参数说明：
abc123def456...: 记住的主节点 replication_id
1000: 断线前的 offset
```

#### 步骤2：主节点判断

```python
# 伪代码
if slave_repl_id != master_repl_id:
    # ID不匹配，需要全量复制
    return "FULLRESYNC"

if slave_offset < backlog_min_offset:
    # offset太旧，已经被覆盖了
    return "FULLRESYNC"

if slave_offset > backlog_max_offset:
    # offset太新？异常情况
    return "FULLRESYNC"

# 可以增量复制
return "CONTINUE"
```

#### 步骤3：响应CONTINUE

```bash
+CONTINUE
```

#### 步骤4：发送增量命令

```bash
# 从 backlog 中获取 offset 1000 到 1200 的命令
SET key1 value1
SET key2 value2
DEL old_key
LPUSH list1 item1
...
```

#### 步骤5：从节点执行命令

```
从节点：
1. 执行每个命令
2. 更新自己的 offset
3. 最终 offset = 1200，与主节点同步
```

---

## 命令传播

### 什么是命令传播？

**全量复制或增量复制完成后，主节点会持续将写命令发送给从节点。**

### 流程

```
客户端                主节点                从节点1    从节点2
  │                    │                      │          │
  │  SET key value    │                      │          │
  ├─────────────────> │                      │          │
  │                    │                      │          │
  │  OK                │                      │          │
  │  <─────────────────┤                      │          │
  │                    │                      │          │
  │                    │  SET key value       │          │
  │                    ├────────────────────> │          │
  │                    │                      │          │
  │                    │  SET key value                  │
  │                    ├─────────────────────────────────>│
  │                    │                      │          │
```

### 实现细节

#### 1. 写命令缓冲

```c
// Redis 源码中的逻辑（伪代码）
void processCommand(client *c) {
    // 执行命令
    call(c);

    // 如果是写命令，传播给从节点
    if (isDirtyCommand(c)) {
        replicationFeedSlaves(c->argv, c->argc);
    }
}
```

#### 2. 异步发送

```
主节点不会等待从节点确认，而是异步发送：

优点：不影响主节点性能
缺点：主从之间可能有短暂的数据不一致
```

#### 3. TCP连接

```
主从之间维持长连接：
- 减少连接开销
- 保持状态
- 支持心跳检测
```

---

## 复制积压缓冲区详解

### 结构

```
环形缓冲区（Ring Buffer）：

┌───────────────────────────────────────────┐
│ Cmd1 | Cmd2 | Cmd3 | ... | CmdN | [空闲] │
└───────────────────────────────────────────┘
  ↑                           ↑
minOffset                  maxOffset
```

### 特点

1. **固定大小**：默认1MB，可配置
2. **环形结构**：写满后从头开始覆盖
3. **FIFO**：先进先出

### 为什么需要它？

**场景分析：**

```
没有 backlog 的情况：
- 从节点短暂断线
- 主节点继续接收写命令
- 从节点重连时，主节点已经忘了之前的命令
- 只能全量复制（重新传输所有数据）

有 backlog 的情况：
- 从节点短暂断线
- 主节点将写命令保存在 backlog 中
- 从节点重连时，主节点可以从 backlog 中找到缺失的命令
- 只需增量复制（只传输缺失的部分）
```

### 大小如何设置？

```bash
公式：
backlog_size = 断线时间(秒) × 每秒写入量(字节)

示例：
预计最长断线时间：60秒
平均每秒写入：50KB
backlog_size = 60 × 50KB = 3MB

配置：
repl-backlog-size 3mb
```

---

## 心跳检测

### REPLCONF ACK

从节点每秒向主节点发送心跳：

```bash
REPLCONF ACK <offset>

示例：
REPLCONF ACK 12345
```

**作用：**

1. **检测主从连接状态**
   ```
   主节点超过一定时间没收到ACK → 认为从节点掉线
   ```

2. **检测命令丢失**
   ```
   主节点 offset: 1000
   从节点 offset: 900
   → 从节点落后了100字节，可能命令丢失
   ```

3. **最小从节点保证**
   ```
   min-slaves-to-write 1
   min-slaves-max-lag 10

   含义：至少有1个从节点，且延迟不超过10秒
   否则，主节点拒绝写入
   ```

### INFO replication

```bash
# 查看复制状态
redis-cli INFO replication

输出：
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6380,state=online,offset=1234,lag=0
slave1:ip=127.0.0.1,port=6381,state=online,offset=1234,lag=1
master_repl_offset:1234
repl_backlog_size:1048576
```

---

## 主从复制的问题

### 1. 数据延迟

**问题：** 主从之间存在复制延迟

```
时间    主节点                从节点
10:00   SET key "v1"         key = "v0"
10:01   客户端读从节点        key = "v0"  ← 读到旧数据
10:02   复制完成             key = "v1"
```

**解决方案：**
- 对一致性要求高的读操作，直接读主节点
- 使用 `WAIT` 命令等待复制完成
- 监控 `lag` 值，超过阈值告警

### 2. 主节点故障

**问题：** 主节点挂了，从节点无法自动升级

**解决方案：** 使用 Redis Sentinel 或 Redis Cluster

### 3. 复制风暴

**问题：** 一个主节点有很多从节点，全量复制时压力大

```
主节点
  ├─ 从节点1 (全量复制，生成RDB)
  ├─ 从节点2 (全量复制，生成RDB)
  ├─ 从节点3 (全量复制，生成RDB)
  └─ ...
```

**解决方案：** 使用级联复制（树形结构）

```
主节点
  ├─ 从节点1
  │    ├─ 从节点1-1
  │    └─ 从节点1-2
  └─ 从节点2
       ├─ 从节点2-1
       └─ 从节点2-2
```

---

## 实际应用场景

### 场景1：读写分离

```
架构：
┌─────────┐
│ 主节点   │ ← 写操作
│ (写)     │
└────┬────┘
     │
     ├────────────┬────────────┐
     ↓            ↓            ↓
┌─────────┐ ┌─────────┐ ┌─────────┐
│ 从节点1  │ │ 从节点2  │ │ 从节点3  │
│ (读)     │ │ (读)     │ │ (读)     │
└─────────┘ └─────────┘ └─────────┘

优点：
- 提高读并发能力
- 减轻主节点压力

注意：
- 可能读到旧数据
- 需要负载均衡
```

### 场景2：数据备份

```
主节点 (生产环境)
  └─ 从节点 (备份)

定期在从节点上：
1. 执行 BGSAVE 生成RDB
2. 或开启 AOF
3. 备份到其他地方

优点：
- 不影响主节点性能
- 有数据副本
```

### 场景3：故障转移

```
使用 Redis Sentinel：

┌──────────────────────────────────┐
│         Sentinel 集群             │
│  (监控主从，自动故障转移)         │
└──────────────────────────────────┘
           ↓
    ┌─────────┐
    │ 主节点   │ × (挂了)
    └─────────┘
         │
    ┌────┴────┐
    ↓         ↓
┌─────────┐ ┌─────────┐
│ 从节点1  │ │ 从节点2  │
└─────────┘ └─────────┘
     ↑
自动升级为主节点
```

---

## 命令总结

### 配置主从复制

```bash
# 从节点配置（方式1：配置文件）
replicaof 127.0.0.1 6379

# 从节点配置（方式2：命令）
redis-cli REPLICAOF 127.0.0.1 6379

# 取消复制，变回主节点
redis-cli REPLICAOF NO ONE
```

### 查看状态

```bash
# 查看复制信息
redis-cli INFO replication

# 查看从节点列表
redis-cli INFO replication | grep slave
```

### 配置参数

```bash
# 主节点配置
repl-backlog-size 1mb           # 积压缓冲区大小
repl-backlog-ttl 3600           # 无从节点时保持缓冲区的时间
min-slaves-to-write 1           # 最少从节点数量
min-slaves-max-lag 10           # 最大延迟时间

# 从节点配置
replicaof 127.0.0.1 6379        # 主节点地址
masterauth password             # 主节点密码
replica-read-only yes           # 只读模式
replica-serve-stale-data yes    # 复制中断时是否继续服务
```

---

## 性能优化建议

### 1. 无磁盘复制

```bash
repl-diskless-sync yes
repl-diskless-sync-delay 5

原理：
传统方式：内存 → RDB文件 → 网络
无磁盘：内存 → 直接通过socket发送 → 网络

优点：
- 减少磁盘I/O
- 更快的复制速度

适用：
- 磁盘慢，网络快的环境
```

### 2. 调整缓冲区大小

```bash
repl-backlog-size 16mb  # 根据实际情况调整
```

### 3. 级联复制

```
主节点
  └─ 中间从节点
       ├─ 叶子从节点1
       ├─ 叶子从节点2
       └─ 叶子从节点3

减少主节点压力
```

### 4. 监控

```bash
# 监控指标
1. master_repl_offset - 主节点偏移量
2. slave_repl_offset - 从节点偏移量
3. repl_backlog_size - 缓冲区大小
4. lag - 延迟时间

# 告警条件
- lag > 10秒
- offset差距过大
- 从节点断开
```

---

## 总结

### 核心流程

```
1. 从节点发送 PSYNC
   ↓
2. 主节点判断：全量 or 增量
   ↓
3. 全量：发送RDB + 缓冲区命令
   增量：发送缺失的命令
   ↓
4. 持续命令传播
   ↓
5. 心跳检测
```

### 关键点

✅ **Replication ID** - 标识数据集
✅ **Replication Offset** - 记录复制进度
✅ **Replication Backlog** - 支持增量复制
✅ **PSYNC** - 智能同步命令
✅ **心跳检测** - 保证数据一致性

### 实战建议

1. 合理设置 backlog 大小
2. 监控主从延迟
3. 使用 Sentinel 实现自动故障转移
4. 考虑读写分离的一致性问题
5. 定期备份 RDB/AOF

---

**掌握主从复制是学习 Redis Sentinel 和 Redis Cluster 的基础！** 🚀
